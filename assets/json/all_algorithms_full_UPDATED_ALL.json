[
  {
    "number": 1,
    "times_viewed": 0,
    "id": "linear_search",
    "name": "Linear Search",
    "description": "Linear Search is a basic searching algorithm that traverses through each element of the array or list sequentially to find the target value. It can be used on both sorted and unsorted data structures.\n\nExplaination:\n\nThe algorithm starts from the first element and compares each item with the target. If a match is found, it returns the index of that element. If it reaches the end without finding the target, it returns -1. This method is simple to implement but inefficient for large datasets.\n\nTime Complexity:\n- Best Case: O(1)\n- Worst Case: O(n)\n- Average Case: O(n)\n\nSpace Complexity: O(1)",
    "java": "public class LinearSearch {\n    public static int search(int[] arr, int target) {\n        for (int i = 0; i < arr.length; i++) {\n            if (arr[i] == target) {\n                return i; // return index if target is found\n            }\n        }\n        return -1; // return -1 if target is not found\n    }\n\n    public static void main(String[] args) {\n        int[] data = {10, 20, 30, 40, 50};\n        int target = 30;\n        int result = search(data, target);\n        System.out.println(result != -1 ? ''Found at index '' + result : ''Not found'');\n    }\n}",
    "python": "def linear_search(arr, target):\n    for i in range(len(arr)):\n        if arr[i] == target:\n            return i  # return index if target is found\n    return -1  # return -1 if target is not found\n\ndata = [10, 20, 30, 40, 50]\ntarget = 30\nresult = linear_search(data, target)\nprint(f''Found at index {result}'' if result != -1 else ''Not found'')",
    "cpp": "#include <iostream>\nusing namespace std;\n\nint linearSearch(int arr[], int n, int target) {\n    for (int i = 0; i < n; i++) {\n        if (arr[i] == target) {\n            return i; // return index if target is found\n        }\n    }\n    return -1; // return -1 if target is not found\n}\n\nint main() {\n    int data[] = {10, 20, 30, 40, 50};\n    int target = 30;\n    int n = sizeof(data) / sizeof(data[0]);\n    int result = linearSearch(data, n, target);\n    if (result != -1)\n        cout << \"Found at index \" << result << endl;\n    else\n        cout << \"Not found\" << endl;\n}",
    "mainImage": "https://res.cloudinary.com/daozctcil/image/upload/v1750965370/f45f5740-e00f-4d16-bd66-2231d6e2c72f.png",
    "slideshowImage": ["https://res.cloudinary.com/daozctcil/image/upload/v1750965494/cad8c4d7-648e-4d1f-9f1b-a3a1c453eff4.png", "https://res.cloudinary.com/daozctcil/image/upload/v1750965547/986cf6c3-d091-4e9b-8bc8-48ec7e75ee6a.png", "https://res.cloudinary.com/daozctcil/image/upload/v1750965583/893b23b5-f854-4197-b1df-1ebd693f85b4.png"],
    "category": [
      "Searching"
    ]
  },
  {
    "number": 2,
    "times_viewed": 0,
    "id": "binary_search",
    "name": "Binary Search",
    "description": "Binary Search is an efficient searching algorithm used on sorted arrays. It works by repeatedly dividing the search interval in half to locate the target value.\n\nExplaination:\nBinary Search starts by comparing the target value with the middle element of the array. If the target equals the middle element, the search is complete. If the target is smaller, the algorithm continues on the left sub-array; if larger, on the right sub-array. This process repeats until the element is found or the sub-array size reduces to zero.\n\nTime Complexity:\n- Best Case: O(1)\n- Worst Case: O(log n)\n- Average Case: O(log n)\n\nSpace Complexity: O(1)",
    "java": "public class BinarySearch {\n    public static int search(int[] arr, int target) {\n        int left = 0, right = arr.length - 1;\n        while (left <= right) {\n            int mid = left + (right - left) / 2;\n            if (arr[mid] == target)\n                return mid;\n            else if (arr[mid] < target)\n                left = mid + 1;\n            else\n                right = mid - 1;\n        }\n        return -1;\n    }\n\n    public static void main(String[] args) {\n        int[] data = {10, 20, 30, 40, 50};\n        int target = 30;\n        int result = search(data, target);\n        System.out.println(result != -1 ? ''Found at index '' + result : ''Not found'');\n    }\n}",
    "python": "def binary_search(arr, target):\n    left, right = 0, len(arr) - 1\n    while left <= right:\n        mid = (left + right) // 2\n        if arr[mid] == target:\n            return mid\n        elif arr[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return -1\n\ndata = [10, 20, 30, 40, 50]\ntarget = 30\nresult = binary_search(data, target)\nprint(f''Found at index {result}'' if result != -1 else ''Not found'')",
    "cpp": "#include <iostream>\nusing namespace std;\n\nint binarySearch(int arr[], int n, int target) {\n    int left = 0, right = n - 1;\n    while (left <= right) {\n        int mid = left + (right - left) / 2;\n        if (arr[mid] == target)\n            return mid;\n        else if (arr[mid] < target)\n            left = mid + 1;\n        else\n            right = mid - 1;\n    }\n    return -1;\n}\n\nint main() {\n    int data[] = {10, 20, 30, 40, 50};\n    int target = 30;\n    int n = sizeof(data) / sizeof(data[0]);\n    int result = binarySearch(data, n, target);\n    if (result != -1)\n        cout << \"Found at index \" << result << endl;\n    else\n        cout << \"Not found\" << endl;\n}",
    "mainImage": "https://res.cloudinary.com/daozctcil/image/upload/v1751004420/2f956752-0368-4314-8ebc-1cd0fdc886e8.png",
    "slideshowImage": ["https://res.cloudinary.com/daozctcil/image/upload/v1751004511/976fb91d-96c7-4b4d-b2f3-819568db36f6.png","https://res.cloudinary.com/daozctcil/image/upload/v1751004544/72211f8c-68bd-4e6a-9e18-3b0c5d40c2f2.png","https://res.cloudinary.com/daozctcil/image/upload/v1751004571/cb9a2920-9b11-4ec1-978e-abc77667e8c4.png","https://res.cloudinary.com/daozctcil/image/upload/v1751004602/f720bd58-0e7e-498c-b023-f066891ec794.png"],
    "category": [
      "Searching"
    ]
  },
  {
    "number": 3,
    "times_viewed": 0,
    "id": "jump_search",
    "name": "Jump Search",
    "description": "Jump Search is a searching algorithm for sorted arrays that checks elements at fixed intervals (or jumps) instead of one by one. It balances between linear and binary search strategies.\n\nExplaination:\nThe array is divided into blocks of size √n. We check the last element of each block to find the block where the element may exist. Once the block is identified, a linear search is performed within it. This method reduces the total number of comparisons compared to linear search on sorted data.\n\nTime Complexity:\n- Best Case: O(1)\n- Worst Case: O(√n)\n- Average Case: O(√n)\n\nSpace Complexity: O(1)",
    "java": "import java.util.*;\npublic class JumpSearch {\n    public static int jumpSearch(int[] arr, int target) {\n        int n = arr.length;\n        int step = (int)Math.floor(Math.sqrt(n));\n        int prev = 0;\n\n        while (arr[Math.min(step, n) - 1] < target) {\n            prev = step;\n            step += (int)Math.floor(Math.sqrt(n));\n            if (prev >= n)\n                return -1;\n        }\n\n        while (arr[prev] < target) {\n            prev++;\n            if (prev == Math.min(step, n))\n                return -1;\n        }\n\n        if (arr[prev] == target)\n            return prev;\n        return -1;\n    }\n\n    public static void main(String[] args) {\n        int[] data = {10, 20, 30, 40, 50, 60, 70};\n        int target = 50;\n        int result = jumpSearch(data, target);\n        System.out.println(result != -1 ? ''Found at index '' + result : ''Not found'');\n    }\n}",
    "python": "import math\ndef jump_search(arr, target):\n    n = len(arr)\n    step = int(math.sqrt(n))\n    prev = 0\n    while prev < n and arr[min(step, n) - 1] < target:\n        prev = step\n        step += int(math.sqrt(n))\n        if prev >= n:\n            return -1\n    while prev < n and arr[prev] < target:\n        prev += 1\n        if prev == min(step, n):\n            return -1\n    if prev < n and arr[prev] == target:\n        return prev\n    return -1\n\ndata = [10, 20, 30, 40, 50, 60, 70]\ntarget = 50\nresult = jump_search(data, target)\nprint(f''Found at index {result}'' if result != -1 else ''Not found'')",
    "cpp": "#include <iostream>\n#include <cmath>\nusing namespace std;\n\nint jumpSearch(int arr[], int n, int target) {\n    int step = sqrt(n);\n    int prev = 0;\n    while (arr[min(step, n) - 1] < target) {\n        prev = step;\n        step += sqrt(n);\n        if (prev >= n)\n            return -1;\n    }\n    while (arr[prev] < target) {\n        prev++;\n        if (prev == min(step, n))\n            return -1;\n    }\n    if (arr[prev] == target)\n        return prev;\n    return -1;\n}\n\nint main() {\n    int data[] = {10, 20, 30, 40, 50, 60, 70};\n    int n = sizeof(data) / sizeof(data[0]);\n    int target = 50;\n    int result = jumpSearch(data, n, target);\n    if (result != -1)\n        cout << \"Found at index \" << result << endl;\n    else\n        cout << \"Not found\" << endl;\n}",
    "mainImage": "https://res.cloudinary.com/daozctcil/image/upload/v1751004755/e3e41ecb-37b2-4bb4-b823-954babbcee5c.png",
    "slideshowImage": ["https://res.cloudinary.com/daozctcil/image/upload/v1751004856/fef7cd39-cff1-4cc3-825f-fbdbf666e650.png","https://res.cloudinary.com/daozctcil/image/upload/v1751004941/0bac3ccc-db3d-48cb-8ba1-145b191fe2b7.png","https://res.cloudinary.com/daozctcil/image/upload/v1751004971/10fe58f4-7387-412e-9b96-c205aad3a757.png"],
    "category": [
      "Searching"
    ]
  },
  {
    "number": 4,
    "times_viewed": 0,
    "id": "interpolation_search",
    "name": "Interpolation Search",
    "description": "Interpolation Search is an improved variant of Binary Search that works on uniformly distributed sorted arrays. It estimates the position of the target using the formula of linear interpolation.\n\nExplaination:\nUnlike Binary Search which always checks the middle, Interpolation Search tries to guess the probable position of the target using the formula:pos = low + ((target - arr[low]) * (high - low)) / (arr[high] - arr[low]).This technique works well when values are evenly spread. If the guessed position has the value, the search ends. Otherwise, the search continues on either the left or right section depending on the comparison.\n\nTime Complexity:\n- Best Case: O(1)\n- Worst Case: O(n)\n- Average Case: O(log log n) (for uniformly distributed data)\n\nSpace Complexity: O(1)",
    "java": "public class InterpolationSearch {\n    public static int interpolationSearch(int[] arr, int target) {\n        int low = 0, high = arr.length - 1;\n        while (low <= high && target >= arr[low] && target <= arr[high]) {\n            if (low == high) {\n                if (arr[low] == target) return low;\n                return -1;\n            }\n            int pos = low + ((target - arr[low]) * (high - low)) / (arr[high] - arr[low]);\n            if (arr[pos] == target)\n                return pos;\n            if (arr[pos] < target)\n                low = pos + 1;\n            else\n                high = pos - 1;\n        }\n        return -1;\n    }\n\n    public static void main(String[] args) {\n        int[] data = {10, 20, 30, 40, 50, 60, 70};\n        int target = 50;\n        int result = interpolationSearch(data, target);\n        System.out.println(result != -1 ? ''Found at index '' + result : ''Not found'');\n    }\n}",
    "python": "def interpolation_search(arr, target):\n    low = 0\n    high = len(arr) - 1\n    while low <= high and target >= arr[low] and target <= arr[high]:\n        if low == high:\n            if arr[low] == target:\n                return low\n            return -1\n        pos = low + ((target - arr[low]) * (high - low)) // (arr[high] - arr[low])\n        if arr[pos] == target:\n            return pos\n        if arr[pos] < target:\n            low = pos + 1\n        else:\n            high = pos - 1\n    return -1\n\ndata = [10, 20, 30, 40, 50, 60, 70]\ntarget = 50\nresult = interpolation_search(data, target)\nprint(f''Found at index {result}'' if result != -1 else ''Not found'')",
    "cpp": "#include <iostream>\nusing namespace std;\n\nint interpolationSearch(int arr[], int n, int target) {\n    int low = 0, high = n - 1;\n    while (low <= high && target >= arr[low] && target <= arr[high]) {\n        if (low == high) {\n            if (arr[low] == target) return low;\n            return -1;\n        }\n        int pos = low + ((target - arr[low]) * (high - low)) / (arr[high] - arr[low]);\n        if (arr[pos] == target)\n            return pos;\n        if (arr[pos] < target)\n            low = pos + 1;\n        else\n            high = pos - 1;\n    }\n    return -1;\n}\n\nint main() {\n    int data[] = {10, 20, 30, 40, 50, 60, 70};\n    int n = sizeof(data) / sizeof(data[0]);\n    int target = 50;\n    int result = interpolationSearch(data, n, target);\n    if (result != -1)\n        cout << \"Found at index \" << result << endl;\n    else\n        cout << \"Not found\" << endl;\n}",
    "mainImage": "https://res.cloudinary.com/daozctcil/image/upload/v1751005120/84f6ec01-9198-4407-8714-01c5391516da.png",
    "slideshowImage": ["https://res.cloudinary.com/daozctcil/image/upload/v1751005149/9d173148-c4fc-46cc-9657-9166be347f87.png","https://res.cloudinary.com/daozctcil/image/upload/v1751005171/07fbed25-860a-4802-9ef2-43f80994d192.png","https://res.cloudinary.com/daozctcil/image/upload/v1751005192/32ed44be-3f34-4483-a363-1b3ee1c187fc.png","https://res.cloudinary.com/daozctcil/image/upload/v1751005213/94d18d6a-54d7-4339-8708-5ee84b60041a.png"],
    "category": [
      "Searching"
    ]
  },
  {
    "number": 5,
    "times_viewed": 0,
    "id": "exponential_search",
    "name": "Exponential Search",
    "description": "Exponential Search is a fast searching algorithm for sorted arrays. It first finds the range where the target might be using exponential jumps, and then applies Binary Search in that range.\n\nExplaination:\nThe algorithm starts at index 1 and repeatedly doubles the index until it finds a value greater than or equal to the target or it exceeds the array bounds. This defines the search range. Then, a standard Binary Search is performed within that range. Exponential Search is efficient for unbounded or infinite-sized arrays.\n\nTime Complexity:\n- Best Case: O(1)\n- Worst Case: O(log n)\n- Average Case: O(log n)\n\nSpace Complexity: O(1)",
    "java": "import java.util.*;\npublic class ExponentialSearch {\n    public static int binarySearch(int[] arr, int left, int right, int target) {\n        while (left <= right) {\n            int mid = left + (right - left) / 2;\n            if (arr[mid] == target)\n                return mid;\n            if (arr[mid] < target)\n                left = mid + 1;\n            else\n                right = mid - 1;\n        }\n        return -1;\n    }\n\n    public static int exponentialSearch(int[] arr, int target) {\n        if (arr[0] == target) return 0;\n        int i = 1;\n        while (i < arr.length && arr[i] <= target)\n            i *= 2;\n        return binarySearch(arr, i / 2, Math.min(i, arr.length - 1), target);\n    }\n\n    public static void main(String[] args) {\n        int[] data = {5, 10, 15, 20, 25, 30, 35, 40};\n        int target = 25;\n        int result = exponentialSearch(data, target);\n        System.out.println(result != -1 ? ''Found at index '' + result : ''Not found'');\n    }\n}",
    "python": "def binary_search(arr, left, right, target):\n    while left <= right:\n        mid = (left + right) // 2\n        if arr[mid] == target:\n            return mid\n        elif arr[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return -1\n\ndef exponential_search(arr, target):\n    if arr[0] == target:\n        return 0\n    i = 1\n    while i < len(arr) and arr[i] <= target:\n        i *= 2\n    return binary_search(arr, i // 2, min(i, len(arr) - 1), target)\n\ndata = [5, 10, 15, 20, 25, 30, 35, 40]\ntarget = 25\nresult = exponential_search(data, target)\nprint(f''Found at index {result}'' if result != -1 else ''Not found'')",
    "cpp": "#include <iostream>\nusing namespace std;\n\nint binarySearch(int arr[], int left, int right, int target) {\n    while (left <= right) {\n        int mid = left + (right - left) / 2;\n        if (arr[mid] == target)\n            return mid;\n        if (arr[mid] < target)\n            left = mid + 1;\n        else\n            right = mid - 1;\n    }\n    return -1;\n}\n\nint exponentialSearch(int arr[], int n, int target) {\n    if (arr[0] == target)\n        return 0;\n    int i = 1;\n    while (i < n && arr[i] <= target)\n        i *= 2;\n    return binarySearch(arr, i / 2, min(i, n - 1), target);\n}\n\nint main() {\n    int data[] = {5, 10, 15, 20, 25, 30, 35, 40};\n    int n = sizeof(data) / sizeof(data[0]);\n    int target = 25;\n    int result = exponentialSearch(data, n, target);\n    if (result != -1)\n        cout << \"Found at index \" << result << endl;\n    else\n        cout << \"Not found\" << endl;\n}",
    "mainImage": "https://res.cloudinary.com/daozctcil/image/upload/v1751005276/e21d6054-0fa0-4d09-b485-adff40e577e1.png",
    "slideshowImage": ["https://res.cloudinary.com/daozctcil/image/upload/v1751005302/2ccb112d-398b-4675-bb76-0b18ae94cfed.png","https://res.cloudinary.com/daozctcil/image/upload/v1751005320/bd918e6c-4bef-432e-8d9e-d7fdb89b7f77.png","https://res.cloudinary.com/daozctcil/image/upload/v1751005339/63e9db34-e5b6-4edb-aa25-d0855ed1c344.png","https://res.cloudinary.com/daozctcil/image/upload/v1751005361/4c107bee-542d-4aea-9768-63b806d365ea.png","https://res.cloudinary.com/daozctcil/image/upload/v1751005379/242b7afc-94c9-4f28-b27a-ec60ae30b263.png","https://res.cloudinary.com/daozctcil/image/upload/v1751005404/73cf1fc3-1e1e-42a2-92e5-7a2a0ad1599d.png","https://res.cloudinary.com/daozctcil/image/upload/v1751005427/9cfb2741-9348-4284-9a70-d5ec3a445e87.png","https://res.cloudinary.com/daozctcil/image/upload/v1751005446/64c0387c-94d4-4571-b277-65db101b3e0c.png"],
    "category": [
      "Searching"
    ]
  },
  {
    "number": 6,
    "times_viewed": 0,
    "id": "ternary_search",
    "name": "Ternary Search",
    "description": "Ternary Search is a divide and conquer algorithm that splits a sorted array into three parts and determines which segment may contain the target value by calculating two mid points using mathematical partitioning/n/nExplaination:/nTernary Search computes two mid indices (mid1 and mid2) to partition the array; it then compares the target with the elements at these indices. Depending on the result, the search is recursively performed in the left segment (if the target is less than the element at mid1), the right segment (if the target is greater than the element at mid2), or the middle segment (if the target lies between the two mid values)/n/nTime Complexity:/n- Best Case: O(1)/n- Worst Case: O(log₃ n)/n- Average Case: O(log₃ n)/n/nSpace Complexity: O(1)",
    "java": "public class TernarySearch {\n    public static int ternarySearch(int[] arr, int left, int right, int target) {\n        if (right >= left) {\n            int mid1 = left + (right - left) / 3;\n            int mid2 = right - (right - left) / 3;\n            if (arr[mid1] == target)\n                return mid1;\n            if (arr[mid2] == target)\n                return mid2;\n            if (target < arr[mid1])\n                return ternarySearch(arr, left, mid1 - 1, target);\n            else if (target > arr[mid2])\n                return ternarySearch(arr, mid2 + 1, right, target);\n            else\n                return ternarySearch(arr, mid1 + 1, mid2 - 1, target);\n        }\n        return -1;\n    }\n\n    public static void main(String[] args) {\n        int[] data = {1, 2, 3, 4, 5, 6, 7, 8, 9};\n        int target = 5;\n        int result = ternarySearch(data, 0, data.length - 1, target);\n        System.out.println(result != -1 ? ''Found at index '' + result : ''Not found'');\n    }\n}\n",
    "python": "def ternary_search(arr, left, right, target):\n    if right >= left:\n        mid1 = left + (right - left) // 3\n        mid2 = right - (right - left) // 3\n        if arr[mid1] == target:\n            return mid1\n        if arr[mid2] == target:\n            return mid2\n        if target < arr[mid1]:\n            return ternary_search(arr, left, mid1 - 1, target)\n        elif target > arr[mid2]:\n            return ternary_search(arr, mid2 + 1, right, target)\n        else:\n            return ternary_search(arr, mid1 + 1, mid2 - 1, target)\n    return -1\n\ndata = [1, 2, 3, 4, 5, 6, 7, 8, 9]\ntarget = 5\nresult = ternary_search(data, 0, len(data) - 1, target)\nprint(f''Found at index {result}'' if result != -1 else ''Not found'')\n",
    "cpp": "#include <iostream>\nusing namespace std;\n\nint ternarySearch(int arr[], int left, int right, int target) {\n    if (right >= left) {\n        int mid1 = left + (right - left) / 3;\n        int mid2 = right - (right - left) / 3;\n        if (arr[mid1] == target)\n            return mid1;\n        if (arr[mid2] == target)\n            return mid2;\n        if (target < arr[mid1])\n            return ternarySearch(arr, left, mid1 - 1, target);\n        else if (target > arr[mid2])\n            return ternarySearch(arr, mid2 + 1, right, target);\n        else\n            return ternarySearch(arr, mid1 + 1, mid2 - 1, target);\n    }\n    return -1;\n}\n\nint main() {\n    int data[] = {1, 2, 3, 4, 5, 6, 7, 8, 9};\n    int n = sizeof(data) / sizeof(data[0]);\n    int target = 5;\n    int result = ternarySearch(data, 0, n - 1, target);\n    if(result != -1)\n        cout << \"Found at index \" << result << endl;\n    else\n        cout << \"Not found\" << endl;\n    return 0;\n}\n",
    "mainImage": "https://res.cloudinary.com/daozctcil/image/upload/v1751005550/4c21e85d-7c70-48f8-9a8b-167b78958803.png",
    "slideshowImage": ["https://res.cloudinary.com/daozctcil/image/upload/v1751005591/da24eed9-f82a-4049-b19e-2021471803bf.png","https://res.cloudinary.com/daozctcil/image/upload/v1751005622/cb97e785-be8f-49d8-a1cd-8bf0a0da4b1e.png","https://res.cloudinary.com/daozctcil/image/upload/v1751005646/b1359acd-a312-47c3-b1c9-1bead6c53ac3.png","https://res.cloudinary.com/daozctcil/image/upload/v1751005667/a372a0d9-2b87-4858-962d-7d2337bfb192.png"],
    "category": [
      "Searching"
    ]
  },
  {
    "number": 7,
    "times_viewed": 0,
    "id": "bubble_sort",
    "name": "Bubble Sort",
    "description": "Bubble Sort is a simple comparison-based sorting algorithm where adjacent elements are repeatedly compared and swapped if they are in the wrong order. This continues until the entire array is sorted.\n\nExplaination:/nBubble Sort works by repeatedly stepping through the list, comparing adjacent pairs and swapping them if needed. Each pass ensures the largest unsorted element bubbles up to its correct position. This process repeats for all elements until the list is fully sorted. Though easy to implement, Bubble Sort is inefficient for large datasets due to its quadratic time complexity.\n\nTime Complexity:/n- Best Case: O(n) (when already sorted)/n- Worst Case: O(n²)/n- Average Case: O(n²)\n\nSpace Complexity: O(1)",
    "java": "public class BubbleSort {\n    public static void bubbleSort(int[] arr) {\n        int n = arr.length;\n        for (int i = 0; i < n - 1; i++) {\n            boolean swapped = false;\n            for (int j = 0; j < n - i - 1; j++) {\n                if (arr[j] > arr[j + 1]) {\n                    int temp = arr[j];\n                    arr[j] = arr[j + 1];\n                    arr[j + 1] = temp;\n                    swapped = true;\n                }\n            }\n            if (!swapped)\n                break;\n        }\n    }\n\n    public static void main(String[] args) {\n        int[] data = {64, 34, 25, 12, 22, 11, 90};\n        bubbleSort(data);\n        for (int num : data) {\n            System.out.print(num + '' '');\n        }\n    }\n}",
    "python": "def bubble_sort(arr):\n    n = len(arr)\n    for i in range(n):\n        swapped = False\n        for j in range(0, n - i - 1):\n            if arr[j] > arr[j + 1]:\n                arr[j], arr[j + 1] = arr[j + 1], arr[j]\n                swapped = True\n        if not swapped:\n            break\n\ndata = [64, 34, 25, 12, 22, 11, 90]\nbubble_sort(data)\nprint('' ''.join(str(x) for x in data))",
    "cpp": "#include <iostream>\nusing namespace std;\n\nvoid bubbleSort(int arr[], int n) {\n    for (int i = 0; i < n - 1; i++) {\n        bool swapped = false;\n        for (int j = 0; j < n - i - 1; j++) {\n            if (arr[j] > arr[j + 1]) {\n                int temp = arr[j];\n                arr[j] = arr[j + 1];\n                arr[j + 1] = temp;\n                swapped = true;\n            }\n        }\n        if (!swapped)\n            break;\n    }\n}\n\nint main() {\n    int data[] = {64, 34, 25, 12, 22, 11, 90};\n    int n = sizeof(data) / sizeof(data[0]);\n    bubbleSort(data, n);\n    for (int i = 0; i < n; i++) {\n        cout << data[i] << \" \";\n    }\n    return 0;\n}",
    "mainImage": "https://res.cloudinary.com/daozctcil/image/upload/v1751005812/733606ab-164c-420a-b75a-ca51587f204e.png",
    "slideshowImage": ["https://res.cloudinary.com/daozctcil/image/upload/v1751005840/c8592c2a-c19d-4ff8-9f9d-6e7b154703b0.png","https://res.cloudinary.com/daozctcil/image/upload/v1751005865/e3d3c39e-4c3e-4df8-a0d4-2a28cea54f6a.png","https://res.cloudinary.com/daozctcil/image/upload/v1751005890/98116fa3-b2a2-49de-aa2d-7b126c2515a7.png"],
    "category": [
      "Sorting"
    ]
  },
  {
    "number": 8,
    "times_viewed": 0,
    "id": "selection_sort",
    "name": "Selection Sort",
    "description": "Selection Sort is a simple comparison-based sorting algorithm that repeatedly selects the smallest (or largest) element from the unsorted part and moves it to the sorted part of the array.\n\nExplaination:/nThe algorithm divides the array into a sorted and unsorted region. Initially, the sorted part is empty. In each iteration, it finds the minimum element from the unsorted part and swaps it with the first element of the unsorted part, effectively growing the sorted region by one. This continues until the entire array is sorted.\n\nTime Complexity:/n- Best Case: O(n²)/n- Worst Case: O(n²)/n- Average Case: O(n²)\n\nSpace Complexity: O(1)",
    "java": "public class SelectionSort {\n    public static void selectionSort(int[] arr) {\n        int n = arr.length;\n        for (int i = 0; i < n - 1; i++) {\n            int minIndex = i;\n            for (int j = i + 1; j < n; j++) {\n                if (arr[j] < arr[minIndex]) {\n                    minIndex = j;\n                }\n            }\n            int temp = arr[minIndex];\n            arr[minIndex] = arr[i];\n            arr[i] = temp;\n        }\n    }\n\n    public static void main(String[] args) {\n        int[] data = {64, 25, 12, 22, 11};\n        selectionSort(data);\n        for (int num : data) {\n            System.out.print(num + '' '');\n        }\n    }\n}",
    "python": "def selection_sort(arr):\n    n = len(arr)\n    for i in range(n):\n        min_index = i\n        for j in range(i + 1, n):\n            if arr[j] < arr[min_index]:\n                min_index = j\n        arr[i], arr[min_index] = arr[min_index], arr[i]\n\ndata = [64, 25, 12, 22, 11]\nselection_sort(data)\nprint('' ''.join(str(x) for x in data))",
    "cpp": "#include <iostream>\nusing namespace std;\n\nvoid selectionSort(int arr[], int n) {\n    for (int i = 0; i < n - 1; i++) {\n        int minIndex = i;\n        for (int j = i + 1; j < n; j++) {\n            if (arr[j] < arr[minIndex]) {\n                minIndex = j;\n            }\n        }\n        int temp = arr[minIndex];\n        arr[minIndex] = arr[i];\n        arr[i] = temp;\n    }\n}\n\nint main() {\n    int data[] = {64, 25, 12, 22, 11};\n    int n = sizeof(data) / sizeof(data[0]);\n    selectionSort(data, n);\n    for (int i = 0; i < n; i++) {\n        cout << data[i] << \" \";\n    }\n    return 0;\n}",
    "mainImage": "https://res.cloudinary.com/daozctcil/image/upload/v1751005958/9353c818-1c43-46b7-a3b1-427a9850408c.png",
    "slideshowImage": ["https://res.cloudinary.com/daozctcil/image/upload/v1751005980/a17a536c-a027-414b-850f-d9fdeb858fb0.png","https://res.cloudinary.com/daozctcil/image/upload/v1751006005/95683a82-6162-41ad-b990-0846c56cfbe6.png","https://res.cloudinary.com/daozctcil/image/upload/v1751006027/e1d7ae7f-747f-41dc-991e-bb208ae19b4c.png","https://res.cloudinary.com/daozctcil/image/upload/v1751006051/4de0c147-86c0-4bf7-95df-59c419dc9248.png","https://res.cloudinary.com/daozctcil/image/upload/v1751006088/44e4394b-fee1-4ff1-91c0-931baad2cc57.png","https://res.cloudinary.com/daozctcil/image/upload/v1751006111/58e45fde-0b46-4101-9ec4-f467f19b746c.png"],
    "category": [
      "Sorting"
    ]
  },
  {
    "number": 9,
    "times_viewed": 0,
    "id": "insertion_sort",
    "name": "Insertion Sort",
    "description": "Insertion Sort is a simple sorting algorithm that builds the final sorted array one element at a time by inserting each item into its correct position relative to those before it.\n\nExplaination:\nInsertion Sort treats the first element as sorted, then takes each next element and inserts it into the correct position among the previously sorted elements. This is done by shifting larger elements one position to the right to make space. It works efficiently for small or nearly sorted arrays.\n\nTime Complexity:\n- Best Case: O(n)\n- Worst Case: O(n²)\n- Average Case: O(n²)\n\nSpace Complexity: O(1)",
    "java": "public class InsertionSort {\n    public static void insertionSort(int[] arr) {\n        int n = arr.length;\n        for (int i = 1; i < n; i++) {\n            int key = arr[i];\n            int j = i - 1;\n            while (j >= 0 && arr[j] > key) {\n                arr[j + 1] = arr[j];\n                j--;\n            }\n            arr[j + 1] = key;\n        }\n    }\n\n    public static void main(String[] args) {\n        int[] data = {12, 11, 13, 5, 6};\n        insertionSort(data);\n        for (int num : data) {\n            System.out.print(num + '' '');\n        }\n    }\n}",
    "python": "def insertion_sort(arr):\n    for i in range(1, len(arr)):\n        key = arr[i]\n        j = i - 1\n        while j >= 0 and arr[j] > key:\n            arr[j + 1] = arr[j]\n            j -= 1\n        arr[j + 1] = key\n\ndata = [12, 11, 13, 5, 6]\ninsertion_sort(data)\nprint('' ''.join(str(x) for x in data))",
    "cpp": "#include <iostream>\nusing namespace std;\n\nvoid insertionSort(int arr[], int n) {\n    for (int i = 1; i < n; i++) {\n        int key = arr[i];\n        int j = i - 1;\n        while (j >= 0 && arr[j] > key) {\n            arr[j + 1] = arr[j];\n            j--;\n        }\n        arr[j + 1] = key;\n    }\n}\n\nint main() {\n    int data[] = {12, 11, 13, 5, 6};\n    int n = sizeof(data) / sizeof(data[0]);\n    insertionSort(data, n);\n    for (int i = 0; i < n; i++) {\n        cout << data[i] << \" \";\n    }\n    return 0;\n}",
    "mainImage": "https://res.cloudinary.com/daozctcil/image/upload/v1751006377/e6359994-f972-4a91-a11b-b3e5632cc35d.png",
    "slideshowImage": ["https://res.cloudinary.com/daozctcil/image/upload/v1751006419/a2b1c981-4bbb-4d05-87df-19737580618f.png","https://res.cloudinary.com/daozctcil/image/upload/v1751006442/9b855209-4079-4d6d-8985-026fd0cb0275.png","https://res.cloudinary.com/daozctcil/image/upload/v1751006471/431327a3-66e0-4712-8c6c-7877fc09f46a.png","https://res.cloudinary.com/daozctcil/image/upload/v1751006500/8ae295cf-5063-4a74-8212-76e0db16a800.png","https://res.cloudinary.com/daozctcil/image/upload/v1751006521/ec2dcb83-d362-41c3-b3fb-f1ef1fdc624c.png"],
    "category": [
      "Sorting"
    ]
  },
  {
    "number": 10,
    "times_viewed": 0,
    "id": "merge_sort",
    "name": "Merge Sort",
    "description": "Merge Sort is a divide and conquer algorithm that recursively divides the array into halves, sorts each half, and then merges them into a fully sorted array.\n\nExplaination:\nMerge Sort splits the array into two halves until each sub-array has only one element. It then merges these sub-arrays in sorted order by comparing the smallest elements of each half. This merging continues recursively until the full array is sorted. It guarantees a stable and efficient sort for large datasets.\n\nTime Complexity:\n- Best Case: O(n log n)\n- Worst Case: O(n log n)\n- Average Case: O(n log n)\n\nSpace Complexity: O(n)",
    "java": "public class MergeSort {\n    public static void mergeSort(int[] arr, int left, int right) {\n        if (left < right) {\n            int mid = (left + right) / 2;\n            mergeSort(arr, left, mid);\n            mergeSort(arr, mid + 1, right);\n            merge(arr, left, mid, right);\n        }\n    }\n\n    public static void merge(int[] arr, int left, int mid, int right) {\n        int n1 = mid - left + 1;\n        int n2 = right - mid;\n        int[] L = new int[n1];\n        int[] R = new int[n2];\n        for (int i = 0; i < n1; i++) L[i] = arr[left + i];\n        for (int j = 0; j < n2; j++) R[j] = arr[mid + 1 + j];\n        int i = 0, j = 0, k = left;\n        while (i < n1 && j < n2) {\n            if (L[i] <= R[j]) arr[k++] = L[i++];\n            else arr[k++] = R[j++];\n        }\n        while (i < n1) arr[k++] = L[i++];\n        while (j < n2) arr[k++] = R[j++];\n    }\n\n    public static void main(String[] args) {\n        int[] data = {38, 27, 43, 3, 9, 82, 10};\n        mergeSort(data, 0, data.length - 1);\n        for (int num : data) {\n            System.out.print(num + '' '');\n        }\n    }\n}",
    "python": "def merge_sort(arr):\n    if len(arr) > 1:\n        mid = len(arr) // 2\n        L = arr[:mid]\n        R = arr[mid:]\n        merge_sort(L)\n        merge_sort(R)\n        i = j = k = 0\n        while i < len(L) and j < len(R):\n            if L[i] < R[j]:\n                arr[k] = L[i]\n                i += 1\n            else:\n                arr[k] = R[j]\n                j += 1\n            k += 1\n        while i < len(L):\n            arr[k] = L[i]\n            i += 1\n            k += 1\n        while j < len(R):\n            arr[k] = R[j]\n            j += 1\n            k += 1\n\ndata = [38, 27, 43, 3, 9, 82, 10]\nmerge_sort(data)\nprint('' ''.join(str(x) for x in data))",
    "cpp": "#include <iostream>\nusing namespace std;\n\nvoid merge(int arr[], int left, int mid, int right) {\n    int n1 = mid - left + 1;\n    int n2 = right - mid;\n    int* L = new int[n1];\n    int* R = new int[n2];\n    for (int i = 0; i < n1; i++) L[i] = arr[left + i];\n    for (int j = 0; j < n2; j++) R[j] = arr[mid + 1 + j];\n    int i = 0, j = 0, k = left;\n    while (i < n1 && j < n2) {\n        if (L[i] <= R[j]) arr[k++] = L[i++];\n        else arr[k++] = R[j++];\n    }\n    while (i < n1) arr[k++] = L[i++];\n    while (j < n2) arr[k++] = R[j++];\n    delete[] L;\n    delete[] R;\n}\n\nvoid mergeSort(int arr[], int left, int right) {\n    if (left < right) {\n        int mid = left + (right - left) / 2;\n        mergeSort(arr, left, mid);\n        mergeSort(arr, mid + 1, right);\n        merge(arr, left, mid, right);\n    }\n}\n\nint main() {\n    int data[] = {38, 27, 43, 3, 9, 82, 10};\n    int n = sizeof(data) / sizeof(data[0]);\n    mergeSort(data, 0, n - 1);\n    for (int i = 0; i < n; i++) {\n        cout << data[i] << \" \";\n    }\n    return 0;\n}",
    "mainImage": "https://res.cloudinary.com/daozctcil/image/upload/v1751014753/1e8d28af-f3e7-407c-8389-af8ed9afbfcf.png",
    "slideshowImage": ["https://res.cloudinary.com/daozctcil/image/upload/v1751014778/46cd17b8-5563-4b85-a8f0-09edc28b7ab4.png","https://res.cloudinary.com/daozctcil/image/upload/v1751014813/59040b09-9199-4e10-a9a8-0620dec52ab9.png","https://res.cloudinary.com/daozctcil/image/upload/v1751014822/d5f3dfbd-d4a0-441d-b2f1-319ac963477a.png","https://res.cloudinary.com/daozctcil/image/upload/v1751014824/0733e9fa-9724-4eb4-b496-ddaa3e3d10bd.png"],
    "category": [
      "Sorting"
    ]
  },
  {
    "number": 11,
    "times_viewed": 0,
    "id": "quick_sort",
    "name": "Quick Sort",
    "description": "Quick Sort is an efficient, divide and conquer sorting algorithm that partitions the array around a pivot, then recursively sorts the subarrays on each side of the pivot.\n\nExplaination:\nQuick Sort selects a pivot element and partitions the array such that elements smaller than the pivot are on the left, and elements greater than the pivot are on the right. It then recursively applies the same logic to the left and right subarrays. Although its worst-case is quadratic, with good pivot choice (like randomized or median), its average performance is very fast.\n\nTime Complexity:\n- Best Case: O(n log n)\n- Worst Case: O(n²)\n- Average Case: O(n log n)\n\nSpace Complexity: O(log n)",
    "java": "public class QuickSort {\n    public static void quickSort(int[] arr, int low, int high) {\n        if (low < high) {\n            int pi = partition(arr, low, high);\n            quickSort(arr, low, pi - 1);\n            quickSort(arr, pi + 1, high);\n        }\n    }\n\n    public static int partition(int[] arr, int low, int high) {\n        int pivot = arr[high];\n        int i = low - 1;\n        for (int j = low; j < high; j++) {\n            if (arr[j] < pivot) {\n                i++;\n                int temp = arr[i];\n                arr[i] = arr[j];\n                arr[j] = temp;\n            }\n        }\n        int temp = arr[i + 1];\n        arr[i + 1] = arr[high];\n        arr[high] = temp;\n        return i + 1;\n    }\n\n    public static void main(String[] args) {\n        int[] data = {10, 7, 8, 9, 1, 5};\n        quickSort(data, 0, data.length - 1);\n        for (int num : data) {\n            System.out.print(num + '' '');\n        }\n    }\n}",
    "python": "def quick_sort(arr, low, high):\n    if low < high:\n        pi = partition(arr, low, high)\n        quick_sort(arr, low, pi - 1)\n        quick_sort(arr, pi + 1, high)\n\ndef partition(arr, low, high):\n    pivot = arr[high]\n    i = low - 1\n    for j in range(low, high):\n        if arr[j] < pivot:\n            i += 1\n            arr[i], arr[j] = arr[j], arr[i]\n    arr[i + 1], arr[high] = arr[high], arr[i + 1]\n    return i + 1\n\ndata = [10, 7, 8, 9, 1, 5]\nquick_sort(data, 0, len(data) - 1)\nprint('' ''.join(str(x) for x in data))",
    "cpp": "#include <iostream>\nusing namespace std;\n\nvoid quickSort(int arr[], int low, int high) {\n    if (low < high) {\n        int pi = partition(arr, low, high);\n        quickSort(arr, low, pi - 1);\n        quickSort(arr, pi + 1, high);\n    }\n}\n\nint partition(int arr[], int low, int high) {\n    int pivot = arr[high];\n    int i = low - 1;\n    for (int j = low; j < high; j++) {\n        if (arr[j] < pivot) {\n            i++;\n            swap(arr[i], arr[j]);\n        }\n    }\n    swap(arr[i + 1], arr[high]);\n    return i + 1;\n}\n\nint main() {\n    int data[] = {10, 7, 8, 9, 1, 5};\n    int n = sizeof(data) / sizeof(data[0]);\n    quickSort(data, 0, n - 1);\n    for (int i = 0; i < n; i++) {\n        cout << data[i] << \" \";\n    }\n    return 0;\n}",
    "mainImage": "https://res.cloudinary.com/daozctcil/image/upload/v1751014911/f01cd35f-5b86-4182-9360-73808c99df69.png",
    "slideshowImage": ["https://res.cloudinary.com/daozctcil/image/upload/v1751014933/a75422a5-8c51-49d8-adda-e047fb500889.png","https://res.cloudinary.com/daozctcil/image/upload/v1751014949/ea9b6e31-4749-40bb-a27c-436fde782010.png","https://res.cloudinary.com/daozctcil/image/upload/v1751014951/892d1d8c-b3a0-4777-be88-be8d7a78a4bb.png","https://res.cloudinary.com/daozctcil/image/upload/v1751014967/ceab2ecf-2db7-43db-bc1b-d05b742f0ad9.png","https://res.cloudinary.com/daozctcil/image/upload/v1751014976/1a8692ab-afa1-4f76-a31e-0672308671a1.png","https://res.cloudinary.com/daozctcil/image/upload/v1751015031/373a4b1d-cde3-4658-832c-3be104f10a69.png"],
    "category": [
      "Sorting"
    ]
  },
  {
    "number": 12,
    "times_viewed": 0,
    "id": "heap_sort",
    "name": "Heap Sort",
    "description": "Heap Sort is a comparison-based sorting algorithm that uses a binary heap data structure to efficiently find and remove the largest element, sorting the array in place.\n\nExplaination:\nHeap Sort first builds a max heap from the input array. The largest element (at the root) is swapped with the last item, then the heap size is reduced by one and heapified again. This process continues, shrinking the heap and placing the next-largest item at the end until the array is fully sorted. It is an in-place algorithm but not stable.\n\nTime Complexity:\n- Best Case: O(n log n)\n- Worst Case: O(n log n)\n- Average Case: O(n log n)\n\nSpace Complexity: O(1)",
    "java": "public class HeapSort {\n    public static void heapSort(int[] arr) {\n        int n = arr.length;\n        for (int i = n / 2 - 1; i >= 0; i--) {\n            heapify(arr, n, i);\n        }\n        for (int i = n - 1; i > 0; i--) {\n            int temp = arr[0];\n            arr[0] = arr[i];\n            arr[i] = temp;\n            heapify(arr, i, 0);\n        }\n    }\n\n    public static void heapify(int[] arr, int n, int i) {\n        int largest = i;\n        int left = 2 * i + 1;\n        int right = 2 * i + 2;\n        if (left < n && arr[left] > arr[largest])\n            largest = left;\n        if (right < n && arr[right] > arr[largest])\n            largest = right;\n        if (largest != i) {\n            int swap = arr[i];\n            arr[i] = arr[largest];\n            arr[largest] = swap;\n            heapify(arr, n, largest);\n        }\n    }\n\n    public static void main(String[] args) {\n        int[] data = {12, 11, 13, 5, 6, 7};\n        heapSort(data);\n        for (int num : data) {\n            System.out.print(num + '' '');\n        }\n    }\n}",
    "python": "def heapify(arr, n, i):\n    largest = i\n    l = 2 * i + 1\n    r = 2 * i + 2\n    if l < n and arr[l] > arr[largest]:\n        largest = l\n    if r < n and arr[r] > arr[largest]:\n        largest = r\n    if largest != i:\n        arr[i], arr[largest] = arr[largest], arr[i]\n        heapify(arr, n, largest)\n\ndef heap_sort(arr):\n    n = len(arr)\n    for i in range(n // 2 - 1, -1, -1):\n        heapify(arr, n, i)\n    for i in range(n - 1, 0, -1):\n        arr[i], arr[0] = arr[0], arr[i]\n        heapify(arr, i, 0)\n\ndata = [12, 11, 13, 5, 6, 7]\nheap_sort(data)\nprint('' ''.join(str(x) for x in data))",
    "cpp": "#include <iostream>\nusing namespace std;\n\nvoid heapify(int arr[], int n, int i) {\n    int largest = i;\n    int l = 2 * i + 1;\n    int r = 2 * i + 2;\n    if (l < n && arr[l] > arr[largest])\n        largest = l;\n    if (r < n && arr[r] > arr[largest])\n        largest = r;\n    if (largest != i) {\n        swap(arr[i], arr[largest]);\n        heapify(arr, n, largest);\n    }\n}\n\nvoid heapSort(int arr[], int n) {\n    for (int i = n / 2 - 1; i >= 0; i--)\n        heapify(arr, n, i);\n    for (int i = n - 1; i > 0; i--) {\n        swap(arr[0], arr[i]);\n        heapify(arr, i, 0);\n    }\n}\n\nint main() {\n    int data[] = {12, 11, 13, 5, 6, 7};\n    int n = sizeof(data) / sizeof(data[0]);\n    heapSort(data, n);\n    for (int i = 0; i < n; i++) {\n        cout << data[i] << \" \";\n    }\n    return 0;\n}",
    "mainImage": "https://res.cloudinary.com/daozctcil/image/upload/v1751015148/2d68bb0d-c537-4eb1-9df7-8487206beab9.png",
    "slideshowImage": [],
    "category": [
      "Sorting"
    ]
  },
  {
    "number": 13,
    "times_viewed": 0,
    "id": "radix_sort",
    "name": "Radix Sort",
    "description": "Radix Sort is a non-comparative integer sorting algorithm that sorts numbers by processing individual digits from least significant to most significant position using a stable sort like counting sort.\n\nExplaination:\nRadix Sort works by first finding the maximum number to determine the number of digits. Then for each digit place (units, tens, hundreds, etc.), it performs a stable sort (typically Counting Sort) based on that digit. Since it does not compare elements directly, it has better performance on fixed-length integer data and is efficient when digit length is small.\n\nTime Complexity:\n- Best Case: O(nk)\n- Worst Case: O(nk)\n- Average Case: O(nk) (where n = number of elements, k = number of digits)\n\nSpace Complexity: O(n + k)",
    "java": "import java.util.*;\npublic class RadixSort {\n    public static void radixSort(int[] arr) {\n        int max = getMax(arr);\n        for (int exp = 1; max / exp > 0; exp *= 10)\n            countingSort(arr, exp);\n    }\n\n    public static int getMax(int[] arr) {\n        int max = arr[0];\n        for (int i = 1; i < arr.length; i++) {\n            if (arr[i] > max)\n                max = arr[i];\n        }\n        return max;\n    }\n\n    public static void countingSort(int[] arr, int exp) {\n        int n = arr.length;\n        int[] output = new int[n];\n        int[] count = new int[10];\n        for (int i = 0; i < n; i++)\n            count[(arr[i] / exp) % 10]++;\n        for (int i = 1; i < 10; i++)\n            count[i] += count[i - 1];\n        for (int i = n - 1; i >= 0; i--) {\n            int digit = (arr[i] / exp) % 10;\n            output[count[digit] - 1] = arr[i];\n            count[digit]--;\n        }\n        for (int i = 0; i < n; i++)\n            arr[i] = output[i];\n    }\n\n    public static void main(String[] args) {\n        int[] data = {170, 45, 75, 90, 802, 24, 2, 66};\n        radixSort(data);\n        for (int num : data) {\n            System.out.print(num + '' '');\n        }\n    }\n}",
    "python": "def counting_sort(arr, exp):\n    n = len(arr)\n    output = [0] * n\n    count = [0] * 10\n    for i in range(n):\n        index = (arr[i] // exp) % 10\n        count[index] += 1\n    for i in range(1, 10):\n        count[i] += count[i - 1]\n    for i in range(n - 1, -1, -1):\n        index = (arr[i] // exp) % 10\n        output[count[index] - 1] = arr[i]\n        count[index] -= 1\n    for i in range(n):\n        arr[i] = output[i]\n\ndef radix_sort(arr):\n    max_num = max(arr)\n    exp = 1\n    while max_num // exp > 0:\n        counting_sort(arr, exp)\n        exp *= 10\n\ndata = [170, 45, 75, 90, 802, 24, 2, 66]\nradix_sort(data)\nprint('' ''.join(str(x) for x in data))",
    "cpp": "#include <iostream>\nusing namespace std;\n\nvoid countingSort(int arr[], int n, int exp) {\n    int output[n];\n    int count[10] = {0};\n    for (int i = 0; i < n; i++)\n        count[(arr[i] / exp) % 10]++;\n    for (int i = 1; i < 10; i++)\n        count[i] += count[i - 1];\n    for (int i = n - 1; i >= 0; i--) {\n        int digit = (arr[i] / exp) % 10;\n        output[count[digit] - 1] = arr[i];\n        count[digit]--;\n    }\n    for (int i = 0; i < n; i++)\n        arr[i] = output[i];\n}\n\nvoid radixSort(int arr[], int n) {\n    int max = arr[0];\n    for (int i = 1; i < n; i++)\n        if (arr[i] > max)\n            max = arr[i];\n    for (int exp = 1; max / exp > 0; exp *= 10)\n        countingSort(arr, n, exp);\n}\n\nint main() {\n    int data[] = {170, 45, 75, 90, 802, 24, 2, 66};\n    int n = sizeof(data) / sizeof(data[0]);\n    radixSort(data, n);\n    for (int i = 0; i < n; i++)\n        cout << data[i] << \" \";\n    return 0;\n}",
    "mainImage": "https://res.cloudinary.com/daozctcil/image/upload/v1751015284/83aaefdc-7245-4957-8fc6-3995fea1fbc5.png",
    "slideshowImage": ["https://res.cloudinary.com/daozctcil/image/upload/v1751015385/f1f90792-581e-4f91-b24f-25a660b01ad3.png","https://res.cloudinary.com/daozctcil/image/upload/v1751015336/5f74565a-9e1e-4a42-aa9e-15b54ac17f76.png","https://res.cloudinary.com/daozctcil/image/upload/v1751015338/a1e3ffbf-4203-4f6f-8c82-58fa52c03531.png","https://res.cloudinary.com/daozctcil/image/upload/v1751015365/90804123-a456-43c0-8cf5-7dd27cc05cef.png","https://res.cloudinary.com/daozctcil/image/upload/v1751015351/5f8b4f0f-13b7-440c-b2a1-1e37edab46b3.png"],
    "category": [
      "Sorting"
    ]
  },
  {
    "number": 14,
    "times_viewed": 0,
    "id": "counting_sort",
    "name": "Counting Sort",
    "description": "Counting Sort is a non-comparison-based sorting algorithm that sorts integers by counting the frequency of each unique value and then placing elements based on their cumulative count.\n\nExplaination:\nCounting Sort finds the range of the input values, creates a count array, and counts the occurrences of each value. It then transforms the count array into a cumulative count array to determine the position of each element in the output. Finally, it places each input value in its correct sorted position. It works best when input values are within a limited range and are non-negative integers.\n\nTime Complexity:\n- Best Case: O(n + k)\n- Worst Case: O(n + k)\n- Average Case: O(n + k) (where k is the range of input values)\n\nSpace Complexity: O(k)",
    "java": "import java.util.*;\npublic class CountingSort {\n    public static void countingSort(int[] arr) {\n        int max = Arrays.stream(arr).max().getAsInt();\n        int[] count = new int[max + 1];\n        for (int num : arr)\n            count[num]++;\n        int index = 0;\n        for (int i = 0; i <= max; i++) {\n            while (count[i]-- > 0) {\n                arr[index++] = i;\n            }\n        }\n    }\n\n    public static void main(String[] args) {\n        int[] data = {4, 2, 2, 8, 3, 3, 1};\n        countingSort(data);\n        for (int num : data) {\n            System.out.print(num + '' '');\n        }\n    }\n}",
    "python": "def counting_sort(arr):\n    max_val = max(arr)\n    count = [0] * (max_val + 1)\n    for num in arr:\n        count[num] += 1\n    index = 0\n    for i in range(len(count)):\n        while count[i] > 0:\n            arr[index] = i\n            index += 1\n            count[i] -= 1\n\ndata = [4, 2, 2, 8, 3, 3, 1]\ncounting_sort(data)\nprint('' ''.join(str(x) for x in data))",
    "cpp": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nvoid countingSort(int arr[], int n) {\n    int max_val = *max_element(arr, arr + n);\n    int count[max_val + 1] = {0};\n    for (int i = 0; i < n; i++)\n        count[arr[i]]++;\n    int index = 0;\n    for (int i = 0; i <= max_val; i++) {\n        while (count[i]-- > 0) {\n            arr[index++] = i;\n        }\n    }\n}\n\nint main() {\n    int data[] = {4, 2, 2, 8, 3, 3, 1};\n    int n = sizeof(data) / sizeof(data[0]);\n    countingSort(data, n);\n    for (int i = 0; i < n; i++) {\n        cout << data[i] << \" \";\n    }\n    return 0;\n}",
    "mainImage": "https://res.cloudinary.com/daozctcil/image/upload/v1751018277/f3823611-47a9-4226-92da-72ed9d598b32.png",
    "slideshowImage": ["https://res.cloudinary.com/daozctcil/image/upload/v1751018310/9d0761ca-659e-4062-8654-9810fa38c1e0.png","https://res.cloudinary.com/daozctcil/image/upload/v1751018317/18a256bd-855f-4e04-8721-e6f5e27cfde7.png","https://res.cloudinary.com/daozctcil/image/upload/v1751018323/ea53b4f7-927b-4237-83fe-d8fc81b91d4b.png","https://res.cloudinary.com/daozctcil/image/upload/v1751018326/515f09f0-e41a-4a83-83c9-1c05b1f908c6.png","https://res.cloudinary.com/daozctcil/image/upload/v1751018337/1c108126-fa81-4171-81cb-f124a9d6e529.png","https://res.cloudinary.com/daozctcil/image/upload/v1751018344/295c006a-7255-41dc-b00a-771df54f6bf7.png","https://res.cloudinary.com/daozctcil/image/upload/v1751018346/a26580fb-4090-4214-bcc4-7f54321eced1.png","https://res.cloudinary.com/daozctcil/image/upload/v1751018356/b961b1ba-8375-4108-a309-73f163191212.png","https://res.cloudinary.com/daozctcil/image/upload/v1751018361/fb1afd16-caec-49c3-a54a-9e4ea995f359.png","https://res.cloudinary.com/daozctcil/image/upload/v1751018368/b55ca6be-1a25-46f7-b2e5-74f92b4c6c5c.png","https://res.cloudinary.com/daozctcil/image/upload/v1751018374/256342aa-5e77-45bd-9538-4579dca1e14a.png","https://res.cloudinary.com/daozctcil/image/upload/v1751018377/a52a3b65-b937-48a0-9244-e7e163ee81ff.png"],
    "category": [
      "Sorting"
    ]
  },
  {
    "number": 15,
    "times_viewed": 0,
    "id": "bucket_sort",
    "name": "Bucket Sort",
    "description": "Bucket Sort is a sorting algorithm that distributes elements into multiple buckets, sorts each bucket individually (using another sorting algorithm), and then concatenates them to form the final sorted array.\n\nExplaination:\nThe algorithm divides the input array into a number of buckets. Each bucket holds a range of values. Elements are distributed into buckets based on their value. After this, each bucket is sorted individually — typically using Insertion Sort or any efficient algorithm. Finally, the sorted buckets are merged to get the fully sorted array. It is particularly effective when the input is uniformly distributed.\n\nTime Complexity:\n- Best Case: O(n + k)\n- Worst Case: O(n²) (when all elements fall into one bucket)\n- Average Case: O(n + k)\n\nSpace Complexity: O(n + k)",
    "java": "import java.util.*;\npublic class BucketSort {\n    public static void bucketSort(float[] arr) {\n        int n = arr.length;\n        List<Float>[] buckets = new ArrayList[n];\n        for (int i = 0; i < n; i++) {\n            buckets[i] = new ArrayList<>();\n        }\n        for (int i = 0; i < n; i++) {\n            int index = (int)(arr[i] * n);\n            buckets[index].add(arr[i]);\n        }\n        for (int i = 0; i < n; i++) {\n            Collections.sort(buckets[i]);\n        }\n        int index = 0;\n        for (int i = 0; i < n; i++) {\n            for (float value : buckets[i]) {\n                arr[index++] = value;\n            }\n        }\n    }\n\n    public static void main(String[] args) {\n        float[] data = {0.897f, 0.565f, 0.656f, 0.123f, 0.665f, 0.343f};\n        bucketSort(data);\n        for (float num : data) {\n            System.out.print(num + '' '');\n        }\n    }\n}",
    "python": "def bucket_sort(arr):\n    n = len(arr)\n    buckets = [[] for _ in range(n)]\n    for num in arr:\n        index = int(num * n)\n        buckets[index].append(num)\n    for bucket in buckets:\n        bucket.sort()\n    result = []\n    for bucket in buckets:\n        result.extend(bucket)\n    for i in range(n):\n        arr[i] = result[i]\n\ndata = [0.897, 0.565, 0.656, 0.123, 0.665, 0.343]\nbucket_sort(data)\nprint('' ''.join(str(x) for x in data))",
    "cpp": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvoid bucketSort(float arr[], int n) {\n    vector<float> buckets[n];\n    for (int i = 0; i < n; i++) {\n        int index = arr[i] * n;\n        buckets[index].push_back(arr[i]);\n    }\n    for (int i = 0; i < n; i++) {\n        sort(buckets[i].begin(), buckets[i].end());\n    }\n    int index = 0;\n    for (int i = 0; i < n; i++) {\n        for (float value : buckets[i]) {\n            arr[index++] = value;\n        }\n    }\n}\n\nint main() {\n    float data[] = {0.897, 0.565, 0.656, 0.123, 0.665, 0.343};\n    int n = sizeof(data) / sizeof(data[0]);\n    bucketSort(data, n);\n    for (int i = 0; i < n; i++) {\n        cout << data[i] << \" \";\n    }\n    return 0;\n}",
    "mainImage": "https://res.cloudinary.com/daozctcil/image/upload/v1751437241/50401558-01dd-462e-81b3-9124d411d6c8.png",
    "slideshowImage": ["https://res.cloudinary.com/daozctcil/image/upload/v1751437276/ba755909-243c-483d-8ef2-83449100bf31.png","https://res.cloudinary.com/daozctcil/image/upload/v1751437291/d862673b-5cfa-439e-b923-46827227e0f7.png","https://res.cloudinary.com/daozctcil/image/upload/v1751437300/e9fca66e-c50a-4df0-8709-1d87eeb0cb2d.png","https://res.cloudinary.com/daozctcil/image/upload/v1751437307/25ad5b72-586f-4e54-9754-9280e5ad97b5.png","https://res.cloudinary.com/daozctcil/image/upload/v1751437310/89d0eeda-9707-4fa3-bf4d-dfb482ff277d.png"],
    "category": [
      "Sorting"
    ]
  },
  {
    "number": 16,
    "times_viewed": 0,
    "id": "shell_sort",
    "name": "Shell Sort",
    "description": "Shell Sort is an in-place comparison-based sorting algorithm that generalizes Insertion Sort by allowing exchanges of elements far apart to move elements closer to their correct positions more quickly.\n\nExplaination:\nShell Sort starts by sorting elements far apart and progressively reduces the gap between elements to be compared. It performs Insertion Sort for each gap. The idea is that sorting elements that are far apart reduces the amount of shifting required in later passes, making it more efficient than a standard Insertion Sort, especially for medium-sized datasets.\n\nTime Complexity:\n- Best Case: O(n log n) (with optimized gap sequences)\n- Worst Case: O(n²)\n- Average Case: Depends on gap sequence, commonly O(n^1.5)\n\nSpace Complexity: O(1)",
    "java": "public class ShellSort {\n    public static void shellSort(int[] arr) {\n        int n = arr.length;\n        for (int gap = n / 2; gap > 0; gap /= 2) {\n            for (int i = gap; i < n; i++) {\n                int temp = arr[i];\n                int j = i;\n                while (j >= gap && arr[j - gap] > temp) {\n                    arr[j] = arr[j - gap];\n                    j -= gap;\n                }\n                arr[j] = temp;\n            }\n        }\n    }\n\n    public static void main(String[] args) {\n        int[] data = {12, 34, 54, 2, 3};\n        shellSort(data);\n        for (int num : data) {\n            System.out.print(num + '' '');\n        }\n    }\n}",
    "python": "def shell_sort(arr):\n    n = len(arr)\n    gap = n // 2\n    while gap > 0:\n        for i in range(gap, n):\n            temp = arr[i]\n            j = i\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            arr[j] = temp\n        gap //= 2\n\ndata = [12, 34, 54, 2, 3]\nshell_sort(data)\nprint('' ''.join(str(x) for x in data))",
    "cpp": "#include <iostream>\nusing namespace std;\n\nvoid shellSort(int arr[], int n) {\n    for (int gap = n / 2; gap > 0; gap /= 2) {\n        for (int i = gap; i < n; i++) {\n            int temp = arr[i];\n            int j = i;\n            while (j >= gap && arr[j - gap] > temp) {\n                arr[j] = arr[j - gap];\n                j -= gap;\n            }\n            arr[j] = temp;\n        }\n    }\n}\n\nint main() {\n    int data[] = {12, 34, 54, 2, 3};\n    int n = sizeof(data) / sizeof(data[0]);\n    shellSort(data, n);\n    for (int i = 0; i < n; i++) {\n        cout << data[i] << \" \";\n    }\n    return 0;\n}",
    "mainImage": "https://res.cloudinary.com/daozctcil/image/upload/v1751437413/f4c3a7dc-2ffc-4642-9ba1-f903ee827b5a.png",
    "slideshowImage": ["https://res.cloudinary.com/daozctcil/image/upload/v1751437462/e3b243ce-8635-4371-82f9-dc6d8315f7ad.png","https://res.cloudinary.com/daozctcil/image/upload/v1751437496/c42cb733-cbbd-46e9-952c-f15571ad3ab7.png","https://res.cloudinary.com/daozctcil/image/upload/v1751437478/c3b8c3d3-7a30-47dc-8fda-972455d2b623.png","https://res.cloudinary.com/daozctcil/image/upload/v1751437504/8ca232f6-6827-4dcf-ba72-1bbd63563941.png","https://res.cloudinary.com/daozctcil/image/upload/v1751437511/ffae9a80-f8d7-4271-b88b-5409c90ef822.png","https://res.cloudinary.com/daozctcil/image/upload/v1751437515/ce300412-cef7-4640-80b7-1336239a95b6.png"],
    "category": [
      "Sorting"
    ]
  },
  {
    "number": 17,
    "times_viewed": 0,
    "id": "timsort",
    "name": "https://res.cloudinary.com/daozctcil/image/upload/v1751437515/ce300412-cef7-4640-80b7-1336239a95b6.png",
    "description": "Tim Sort is a hybrid stable sorting algorithm derived from Merge Sort and Insertion Sort, designed to perform efficiently on many kinds of real-world data.\n\nExplaination:\nTim Sort divides the array into small segments called runs, each of which is sorted using Insertion Sort. Then it merges the runs using a technique similar to Merge Sort. This combination gives Tim Sort both fast performance on nearly sorted data and consistent performance across large datasets. It is the default sorting algorithm in Python and Java’s standard library for objects.\n\nTime Complexity:\n- Best Case: O(n)\n- Worst Case: O(n log n)\n- Average Case: O(n log n)\n\nSpace Complexity: O(n)",
    "java": "import java.util.*;\npublic class TimSort {\n    static int RUN = 32;\n\n    public static void insertionSort(int[] arr, int left, int right) {\n        for (int i = left + 1; i <= right; i++) {\n            int temp = arr[i];\n            int j = i - 1;\n            while (j >= left && arr[j] > temp) {\n                arr[j + 1] = arr[j];\n                j--;\n            }\n            arr[j + 1] = temp;\n        }\n    }\n\n    public static void merge(int[] arr, int l, int m, int r) {\n        int len1 = m - l + 1, len2 = r - m;\n        int[] left = new int[len1];\n        int[] right = new int[len2];\n        for (int i = 0; i < len1; i++)\n            left[i] = arr[l + i];\n        for (int i = 0; i < len2; i++)\n            right[i] = arr[m + 1 + i];\n        int i = 0, j = 0, k = l;\n        while (i < len1 && j < len2) {\n            if (left[i] <= right[j])\n                arr[k++] = left[i++];\n            else\n                arr[k++] = right[j++];\n        }\n        while (i < len1)\n            arr[k++] = left[i++];\n        while (j < len2)\n            arr[k++] = right[j++];\n    }\n\n    public static void timSort(int[] arr, int n) {\n        for (int i = 0; i < n; i += RUN)\n            insertionSort(arr, i, Math.min((i + RUN - 1), (n - 1)));\n        for (int size = RUN; size < n; size = 2 * size) {\n            for (int left = 0; left < n; left += 2 * size) {\n                int mid = left + size - 1;\n                int right = Math.min((left + 2 * size - 1), (n - 1));\n                if (mid < right)\n                    merge(arr, left, mid, right);\n            }\n        }\n    }\n\n    public static void main(String[] args) {\n        int[] data = {5, 21, 7, 23, 19};\n        timSort(data, data.length);\n        for (int num : data) {\n            System.out.print(num + '' '');\n        }\n    }\n}",
    "python": "def insertion_sort(arr, left, right):\n    for i in range(left + 1, right + 1):\n        temp = arr[i]\n        j = i - 1\n        while j >= left and arr[j] > temp:\n            arr[j + 1] = arr[j]\n            j -= 1\n        arr[j + 1] = temp\n\ndef merge(arr, l, m, r):\n    left = arr[l:m + 1]\n    right = arr[m + 1:r + 1]\n    i = j = 0\n    k = l\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            arr[k] = left[i]\n            i += 1\n        else:\n            arr[k] = right[j]\n            j += 1\n        k += 1\n    while i < len(left):\n        arr[k] = left[i]\n        i += 1\n        k += 1\n    while j < len(right):\n        arr[k] = right[j]\n        j += 1\n        k += 1\n\ndef tim_sort(arr):\n    n = len(arr)\n    RUN = 32\n    for i in range(0, n, RUN):\n        insertion_sort(arr, i, min(i + RUN - 1, n - 1))\n    size = RUN\n    while size < n:\n        for left in range(0, n, 2 * size):\n            mid = left + size - 1\n            right = min((left + 2 * size - 1), (n - 1))\n            if mid < right:\n                merge(arr, left, mid, right)\n        size *= 2\n\ndata = [5, 21, 7, 23, 19]\ntim_sort(data)\nprint('' ''.join(str(x) for x in data))",
    "cpp": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\nconst int RUN = 32;\n\nvoid insertionSort(int arr[], int left, int right) {\n    for (int i = left + 1; i <= right; i++) {\n        int temp = arr[i];\n        int j = i - 1;\n        while (j >= left && arr[j] > temp) {\n            arr[j + 1] = arr[j];\n            j--;\n        }\n        arr[j + 1] = temp;\n    }\n}\n\nvoid merge(int arr[], int l, int m, int r) {\n    int len1 = m - l + 1, len2 = r - m;\n    int* left = new int[len1];\n    int* right = new int[len2];\n    for (int i = 0; i < len1; i++) left[i] = arr[l + i];\n    for (int i = 0; i < len2; i++) right[i] = arr[m + 1 + i];\n    int i = 0, j = 0, k = l;\n    while (i < len1 && j < len2) {\n        if (left[i] <= right[j]) arr[k++] = left[i++];\n        else arr[k++] = right[j++];\n    }\n    while (i < len1) arr[k++] = left[i++];\n    while (j < len2) arr[k++] = right[j++];\n    delete[] left;\n    delete[] right;\n}\n\nvoid timSort(int arr[], int n) {\n    for (int i = 0; i < n; i += RUN)\n        insertionSort(arr, i, min(i + RUN - 1, n - 1));\n    for (int size = RUN; size < n; size *= 2) {\n        for (int left = 0; left < n; left += 2 * size) {\n            int mid = left + size - 1;\n            int right = min(left + 2 * size - 1, n - 1);\n            if (mid < right)\n                merge(arr, left, mid, right);\n        }\n    }\n}\n\nint main() {\n    int data[] = {5, 21, 7, 23, 19};\n    int n = sizeof(data) / sizeof(data[0]);\n    timSort(data, n);\n    for (int i = 0; i < n; i++)\n        cout << data[i] << \" \";\n    return 0;\n}",
    "mainImage": "https://res.cloudinary.com/daozctcil/image/upload/v1751437702/8df38a90-99b2-4e19-ab7e-d239682c45aa.png",
    "slideshowImage": [],
    "category": [
      "Sorting"
    ]
  },
  {
    "number": 18,
    "times_viewed": 0,
    "id": "0/1_knapsack",
    "name": "0/1 Knapsack",
    "description": "The 0/1 Knapsack problem is a classic dynamic programming problem that determines the maximum value that can be obtained from a set of items, each with a weight and value, without exceeding the total weight capacity of the knapsack.\n\nExplaination:\nIn the 0/1 Knapsack problem, each item can be either included or excluded (no fractions). We use a 2D dynamic programming table where dp[i][w] represents the maximum value using the first i items with total weight at most w. For each item, we check if its weight is less than or equal to the current capacity. If yes, we take the maximum of including or excluding the item. The final cell dp[n][W] holds the solution.\n\nTime Complexity:\n- O(nW) where n = number of items, W = knapsack capacity\n\nSpace Complexity: O(nW) (can be optimized to O(W) using a 1D array)",
    "java": "public class Knapsack01 {\n    public static int knapsack(int[] weights, int[] values, int W) {\n        int n = weights.length;\n        int[][] dp = new int[n + 1][W + 1];\n        for (int i = 1; i <= n; i++) {\n            for (int w = 1; w <= W; w++) {\n                if (weights[i - 1] <= w)\n                    dp[i][w] = Math.max(values[i - 1] + dp[i - 1][w - weights[i - 1]], dp[i - 1][w]);\n                else\n                    dp[i][w] = dp[i - 1][w];\n            }\n        }\n        return dp[n][W];\n    }\n\n    public static void main(String[] args) {\n        int[] weights = {1, 3, 4, 5};\n        int[] values = {1, 4, 5, 7};\n        int capacity = 7;\n        int maxVal = knapsack(weights, values, capacity);\n        System.out.println(''Maximum value: '' + maxVal);\n    }\n}",
    "python": "def knapsack(weights, values, W):\n    n = len(weights)\n    dp = [[0 for _ in range(W + 1)] for _ in range(n + 1)]\n    for i in range(1, n + 1):\n        for w in range(1, W + 1):\n            if weights[i - 1] <= w:\n                dp[i][w] = max(values[i - 1] + dp[i - 1][w - weights[i - 1]], dp[i - 1][w])\n            else:\n                dp[i][w] = dp[i - 1][w]\n    return dp[n][W]\n\nweights = [1, 3, 4, 5]\nvalues = [1, 4, 5, 7]\ncapacity = 7\nprint(f''Maximum value: {knapsack(weights, values, capacity)}'')",
    "cpp": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint knapsack(vector<int>& weights, vector<int>& values, int W) {\n    int n = weights.size();\n    vector<vector<int>> dp(n + 1, vector<int>(W + 1, 0));\n    for (int i = 1; i <= n; i++) {\n        for (int w = 1; w <= W; w++) {\n            if (weights[i - 1] <= w)\n                dp[i][w] = max(values[i - 1] + dp[i - 1][w - weights[i - 1]], dp[i - 1][w]);\n            else\n                dp[i][w] = dp[i - 1][w];\n        }\n    }\n    return dp[n][W];\n}\n\nint main() {\n    vector<int> weights = {1, 3, 4, 5};\n    vector<int> values = {1, 4, 5, 7};\n    int capacity = 7;\n    cout << \"Maximum value: \" << knapsack(weights, values, capacity) << endl;\n    return 0;\n}",
    "mainImage": "https://res.cloudinary.com/daozctcil/image/upload/v1751437946/241044e0-7fb3-4b06-9db4-3490deeac2bf.png",
    "slideshowImage": ["https://res.cloudinary.com/daozctcil/image/upload/v1751437980/1f88fbfa-fa44-4170-a6ed-0b5e6ec0c52f.png","https://res.cloudinary.com/daozctcil/image/upload/v1751438009/31042da0-493a-438b-98b3-458c1634a757.png","https://res.cloudinary.com/daozctcil/image/upload/v1751438048/46b037d1-d748-41e5-af59-03c256bf6ad2.png"],
    "category": [
      "Dynamic & Greedy"
    ]
  },
  {
    "number": 19,
    "times_viewed": 0,
    "id": "fractional_knapsack",
    "name": "Fractional Knapsack",
    "description": "The Fractional Knapsack problem allows taking fractions of items to maximize total value in a knapsack with limited weight capacity, making it a greedy algorithm unlike the 0/1 Knapsack.\n\nExplaination:\nIn this problem, each item has a value and a weight. Items can be broken into smaller parts, meaning we can take any fraction of an item. We calculate the value-to-weight ratio of each item, sort items in descending order based on this ratio, and greedily add items to the knapsack until it's full. If the item can't be fully added, we add the fraction that fits. This guarantees the maximum total value possible.\n\nTime Complexity:\n- O(n log n) due to sorting\n\nSpace Complexity: O(1) (ignoring input storage)",
    "java": "import java.util.*;\nclass Item {\n    int value, weight;\n    Item(int v, int w) {\n        value = v;\n        weight = w;\n    }\n}\n\npublic class FractionalKnapsack {\n    public static double getMaxValue(Item[] items, int capacity) {\n        Arrays.sort(items, (a, b) -> Double.compare((double)b.value / b.weight, (double)a.value / a.weight));\n        double totalValue = 0.0;\n        for (Item item : items) {\n            if (capacity >= item.weight) {\n                capacity -= item.weight;\n                totalValue += item.value;\n            } else {\n                totalValue += (double)item.value * capacity / item.weight;\n                break;\n            }\n        }\n        return totalValue;\n    }\n\n    public static void main(String[] args) {\n        Item[] items = { new Item(60, 10), new Item(100, 20), new Item(120, 30) };\n        int capacity = 50;\n        System.out.println(''Maximum value: '' + getMaxValue(items, capacity));\n    }\n}",
    "python": "class Item:\n    def __init__(self, value, weight):\n        self.value = value\n        self.weight = weight\n\ndef fractional_knapsack(items, capacity):\n    items.sort(key=lambda x: x.value / x.weight, reverse=True)\n    total_value = 0.0\n    for item in items:\n        if capacity >= item.weight:\n            capacity -= item.weight\n            total_value += item.value\n        else:\n            total_value += item.value * (capacity / item.weight)\n            break\n    return total_value\n\nitems = [Item(60, 10), Item(100, 20), Item(120, 30)]\ncapacity = 50\nprint(f''Maximum value: {fractional_knapsack(items, capacity)}'')",
    "cpp": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nstruct Item {\n    int value, weight;\n};\n\nbool cmp(Item a, Item b) {\n    double r1 = (double)a.value / a.weight;\n    double r2 = (double)b.value / b.weight;\n    return r1 > r2;\n}\n\ndouble fractionalKnapsack(int W, vector<Item>& items) {\n    sort(items.begin(), items.end(), cmp);\n    double totalValue = 0.0;\n    for (auto& item : items) {\n        if (W >= item.weight) {\n            W -= item.weight;\n            totalValue += item.value;\n        } else {\n            totalValue += (double)item.value * W / item.weight;\n            break;\n        }\n    }\n    return totalValue;\n}\n\nint main() {\n    vector<Item> items = {{60, 10}, {100, 20}, {120, 30}};\n    int capacity = 50;\n    cout << \"Maximum value: \" << fractionalKnapsack(capacity, items) << endl;\n    return 0;\n}",
    "mainImage": "https://res.cloudinary.com/daozctcil/image/upload/v1751438089/d1bcb510-62ac-4bc4-b20a-d75ac84b9a51.png",
    "slideshowImage": ["https://res.cloudinary.com/daozctcil/image/upload/v1751438291/5cda561d-8072-41a4-8814-95082e01e0f4.png","https://res.cloudinary.com/daozctcil/image/upload/v1751438308/c356ddc7-d1b0-4ce3-9af1-a8101b44d372.png","https://res.cloudinary.com/daozctcil/image/upload/v1751438310/7b57ee43-df36-43ea-8fcc-50c6c75d6b85.png"],
    "category": [
      "Dynamic & Greedy"
    ]
  },
  {
    "number": 20,
    "times_viewed": 0,
    "id": "longest_common_subsequence",
    "name": "LCS - Longest Common Subsequence",
    "description": "Longest Common Subsequence (LCS) is a classic dynamic programming problem that finds the longest subsequence present in both sequences in the same order but not necessarily contiguously.\n\nExplaination:\nLCS builds a 2D dynamic programming table dp[i][j] where each cell represents the length of the LCS between the first i characters of string A and the first j characters of string B. If characters match, we add 1 to the previous diagonal cell. Otherwise, we take the maximum from the left or top cell. The bottom-right cell gives the length of the LCS. This problem has applications in diff tools, DNA sequencing, and version control systems.\n\nTime Complexity:\n- O(m × n), where m and n are lengths of the two strings\n\nSpace Complexity: O(m × n)",
    "java": "public class LCS {\n    public static int longestCommonSubsequence(String s1, String s2) {\n        int m = s1.length(), n = s2.length();\n        int[][] dp = new int[m + 1][n + 1];\n        for (int i = 1; i <= m; i++) {\n            for (int j = 1; j <= n; j++) {\n                if (s1.charAt(i - 1) == s2.charAt(j - 1))\n                    dp[i][j] = 1 + dp[i - 1][j - 1];\n                else\n                    dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);\n            }\n        }\n        return dp[m][n];\n    }\n\n    public static void main(String[] args) {\n        String s1 = \"ABCBDAB\", s2 = \"BDCAB\";\n        System.out.println(\"Length of LCS: \" + longestCommonSubsequence(s1, s2));\n    }\n}",
    "python": "def lcs(s1, s2):\n    m, n = len(s1), len(s2)\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if s1[i - 1] == s2[j - 1]:\n                dp[i][j] = 1 + dp[i - 1][j - 1]\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n    return dp[m][n]\n\ns1 = \"ABCBDAB\"\ns2 = \"BDCAB\"\nprint(f''Length of LCS: {lcs(s1, s2)}'')",
    "cpp": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nint lcs(const string& s1, const string& s2) {\n    int m = s1.length(), n = s2.length();\n    vector<vector<int>> dp(m + 1, vector<int>(n + 1, 0));\n    for (int i = 1; i <= m; i++) {\n        for (int j = 1; j <= n; j++) {\n            if (s1[i - 1] == s2[j - 1])\n                dp[i][j] = 1 + dp[i - 1][j - 1];\n            else\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);\n        }\n    }\n    return dp[m][n];\n}\n\nint main() {\n    string s1 = \"ABCBDAB\", s2 = \"BDCAB\";\n    cout << \"Length of LCS: \" << lcs(s1, s2) << endl;\n    return 0;\n}",
    "mainImage": "https://res.cloudinary.com/daozctcil/image/upload/v1751438374/50069335-d57d-4242-95ed-a98603240d61.png",
    "slideshowImage": ["https://res.cloudinary.com/daozctcil/image/upload/v1751438435/10a8eebb-7f61-4613-92a0-5f24a9d91cb7.png","https://res.cloudinary.com/daozctcil/image/upload/v1751438437/53235405-96ea-4522-b504-71671149d975.png","https://res.cloudinary.com/daozctcil/image/upload/v1751438448/a66696a3-dba1-4873-a64d-683f374325d9.png","https://res.cloudinary.com/daozctcil/image/upload/v1751438464/8d505391-2298-4711-8c5b-74c6660150c7.png","https://res.cloudinary.com/daozctcil/image/upload/v1751438461/7ad0f416-e685-4951-8d09-0abc9f2e9d8d.png"],
    "category": [
      "Dynamic & Greedy"
    ]
  },
  {
    "number": 21,
    "times_viewed": 0,
    "id": "longest_increasing_subsequence",
    "name": "LIS - Longest Increasing Subsequence",
    "description": "The Longest Increasing Subsequence (LIS) problem finds the longest subsequence of a sequence such that all elements of the subsequence are sorted in increasing order.\n\nExplaination:\nWe use dynamic programming where dp[i] stores the length of the LIS ending at index i. For each element, we look back at all previous elements and update dp[i] if a smaller element is found, adding 1 to its LIS length. The maximum value in the dp array at the end gives the answer. LIS has applications in bioinformatics, version tracking, and sequence analysis.\n\nTime Complexity:\n- O(n²) with basic DP (can be improved to O(n log n) using binary search)\n\nSpace Complexity: O(n)",
    "java": "public class LIS {\n    public static int longestIncreasingSubsequence(int[] nums) {\n        int n = nums.length;\n        int[] dp = new int[n];\n        int maxLen = 1;\n        for (int i = 0; i < n; i++) {\n            dp[i] = 1;\n            for (int j = 0; j < i; j++) {\n                if (nums[i] > nums[j])\n                    dp[i] = Math.max(dp[i], dp[j] + 1);\n            }\n            maxLen = Math.max(maxLen, dp[i]);\n        }\n        return maxLen;\n    }\n\n    public static void main(String[] args) {\n        int[] data = {10, 9, 2, 5, 3, 7, 101, 18};\n        System.out.println(\"Length of LIS: \" + longestIncreasingSubsequence(data));\n    }\n}",
    "python": "def lis(arr):\n    n = len(arr)\n    dp = [1] * n\n    for i in range(n):\n        for j in range(i):\n            if arr[i] > arr[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n    return max(dp)\n\ndata = [10, 9, 2, 5, 3, 7, 101, 18]\nprint(f''Length of LIS: {lis(data)}'')",
    "cpp": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint lis(vector<int>& arr) {\n    int n = arr.size();\n    vector<int> dp(n, 1);\n    int maxLen = 1;\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < i; j++) {\n            if (arr[i] > arr[j])\n                dp[i] = max(dp[i], dp[j] + 1);\n        }\n        maxLen = max(maxLen, dp[i]);\n    }\n    return maxLen;\n}\n\nint main() {\n    vector<int> data = {10, 9, 2, 5, 3, 7, 101, 18};\n    cout << \"Length of LIS: \" << lis(data) << endl;\n    return 0;\n}",
    "mainImage": "https://res.cloudinary.com/daozctcil/image/upload/v1751438539/f99fa153-030c-43e2-9db3-27bd87911d2f.png",
    "slideshowImage": [],
    "category": [
      "Dynamic & Greedy"
    ]
  },
  {
    "number": 26,
    "times_viewed": 0,
    "id": "edit_distance",
    "name": "Edit Distance",
    "description": "The Edit Distance problem finds the minimum number of operations (insert, delete, replace) required to convert one string into another using dynamic programming.\n\nExplaination:\nWe define a 2D dp table where dp[i][j] represents the minimum number of operations needed to convert the first i characters of string s1 to the first j characters of string s2. If the characters match, no operation is needed. If they don’t, we take the minimum among inserting, deleting, or replacing a character. The final answer lies in dp[m][n] where m and n are lengths of the two strings.\n\nTime Complexity:\n- O(m × n)\n\nSpace Complexity: O(m × n)",
    "java": "public class EditDistance {\n    public static int minDistance(String s1, String s2) {\n        int m = s1.length(), n = s2.length();\n        int[][] dp = new int[m + 1][n + 1];\n        for (int i = 0; i <= m; i++) {\n            for (int j = 0; j <= n; j++) {\n                if (i == 0)\n                    dp[i][j] = j;\n                else if (j == 0)\n                    dp[i][j] = i;\n                else if (s1.charAt(i - 1) == s2.charAt(j - 1))\n                    dp[i][j] = dp[i - 1][j - 1];\n                else\n                    dp[i][j] = 1 + Math.min(dp[i - 1][j - 1], Math.min(dp[i][j - 1], dp[i - 1][j]));\n            }\n        }\n        return dp[m][n];\n    }\n\n    public static void main(String[] args) {\n        String s1 = \"kitten\", s2 = \"sitting\";\n        System.out.println(\"Edit distance: \" + minDistance(s1, s2));\n    }\n}",
    "python": "def edit_distance(s1, s2):\n    m, n = len(s1), len(s2)\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    for i in range(m + 1):\n        for j in range(n + 1):\n            if i == 0:\n                dp[i][j] = j\n            elif j == 0:\n                dp[i][j] = i\n            elif s1[i - 1] == s2[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1]\n            else:\n                dp[i][j] = 1 + min(dp[i - 1][j - 1], dp[i][j - 1], dp[i - 1][j])\n    return dp[m][n]\n\ns1 = \"kitten\"\ns2 = \"sitting\"\nprint(f''Edit distance: {edit_distance(s1, s2)}'')",
    "cpp": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nint editDistance(const string& s1, const string& s2) {\n    int m = s1.size(), n = s2.size();\n    vector<vector<int>> dp(m + 1, vector<int>(n + 1));\n    for (int i = 0; i <= m; i++) {\n        for (int j = 0; j <= n; j++) {\n            if (i == 0)\n                dp[i][j] = j;\n            else if (j == 0)\n                dp[i][j] = i;\n            else if (s1[i - 1] == s2[j - 1])\n                dp[i][j] = dp[i - 1][j - 1];\n            else\n                dp[i][j] = 1 + min({dp[i - 1][j - 1], dp[i][j - 1], dp[i - 1][j]});\n        }\n    }\n    return dp[m][n];\n}\n\nint main() {\n    string s1 = \"kitten\", s2 = \"sitting\";\n    cout << \"Edit distance: \" << editDistance(s1, s2) << endl;\n    return 0;\n}",
    "mainImage": "https://res.cloudinary.com/daozctcil/image/upload/v1751439222/6c6828e6-18bc-437c-84f8-b7870f4fbc03.png",
    "slideshowImage": [],
    "category": [
      "Dynamic & Greedy"
    ]
  },
  {
    "number": 27,
    "times_viewed": 0,
    "id": "job_scheduling",
    "name": "Job Scheduling",
    "description": "The Job Scheduling problem finds the maximum profit subset of jobs where each job has a start time, end time, and profit, and no two jobs in the selected subset overlap.\n\nExplaination:\nThis is a classic dynamic programming problem where jobs are first sorted by end time. For each job i, we either include it (and add its profit to the max profit of the last non-conflicting job) or exclude it (take profit from previous job). A binary search is used to find the latest non-conflicting job to optimize the solution. The maximum of all possibilities gives the result. This approach is similar to weighted interval scheduling.\n\nTime Complexity:\n- O(n log n), due to sorting and binary search\n\nSpace Complexity: O(n)",
    "java": "import java.util.*;\nclass Job {\n    int start, end, profit;\n    Job(int s, int e, int p) {\n        start = s; end = e; profit = p;\n    }\n}\n\npublic class JobScheduling {\n    public static int jobScheduling(int[] startTime, int[] endTime, int[] profit) {\n        int n = startTime.length;\n        Job[] jobs = new Job[n];\n        for (int i = 0; i < n; i++)\n            jobs[i] = new Job(startTime[i], endTime[i], profit[i]);\n        Arrays.sort(jobs, Comparator.comparingInt(a -> a.end));\n        int[] dp = new int[n];\n        dp[0] = jobs[0].profit;\n        for (int i = 1; i < n; i++) {\n            int incl = jobs[i].profit;\n            int l = binarySearch(jobs, i);\n            if (l != -1) incl += dp[l];\n            dp[i] = Math.max(incl, dp[i - 1]);\n        }\n        return dp[n - 1];\n    }\n\n    private static int binarySearch(Job[] jobs, int index) {\n        int low = 0, high = index - 1;\n        while (low <= high) {\n            int mid = (low + high) / 2;\n            if (jobs[mid].end <= jobs[index].start) {\n                if (jobs[mid + 1].end <= jobs[index].start)\n                    low = mid + 1;\n                else\n                    return mid;\n            } else {\n                high = mid - 1;\n            }\n        }\n        return -1;\n    }\n\n    public static void main(String[] args) {\n        int[] start = {1, 2, 3, 3};\n        int[] end = {3, 4, 5, 6};\n        int[] profit = {50, 10, 40, 70};\n        System.out.println(\"Maximum profit: \" + jobScheduling(start, end, profit));\n    }\n}",
    "python": "from bisect import bisect_right\n\ndef job_scheduling(start, end, profit):\n    jobs = sorted(zip(start, end, profit), key=lambda x: x[1])\n    n = len(jobs)\n    dp = [0] * n\n    starts = [jobs[i][0] for i in range(n)]\n    dp[0] = jobs[0][2]\n    for i in range(1, n):\n        incl = jobs[i][2]\n        l = bisect_right([jobs[j][1] for j in range(i)], jobs[i][0]) - 1\n        if l >= 0:\n            incl += dp[l]\n        dp[i] = max(dp[i - 1], incl)\n    return dp[-1]\n\nstart = [1, 2, 3, 3]\nend = [3, 4, 5, 6]\nprofit = [50, 10, 40, 70]\nprint(f''Maximum profit: {job_scheduling(start, end, profit)}'')",
    "cpp": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nstruct Job {\n    int start, end, profit;\n};\n\nbool compare(Job a, Job b) {\n    return a.end < b.end;\n}\n\nint binarySearch(vector<Job>& jobs, int index) {\n    int low = 0, high = index - 1;\n    while (low <= high) {\n        int mid = (low + high) / 2;\n        if (jobs[mid].end <= jobs[index].start) {\n            if (jobs[mid + 1].end <= jobs[index].start)\n                low = mid + 1;\n            else\n                return mid;\n        } else {\n            high = mid - 1;\n        }\n    }\n    return -1;\n}\n\nint jobScheduling(vector<Job>& jobs) {\n    sort(jobs.begin(), jobs.end(), compare);\n    int n = jobs.size();\n    vector<int> dp(n);\n    dp[0] = jobs[0].profit;\n    for (int i = 1; i < n; i++) {\n        int incl = jobs[i].profit;\n        int l = binarySearch(jobs, i);\n        if (l != -1)\n            incl += dp[l];\n        dp[i] = max(dp[i - 1], incl);\n    }\n    return dp[n - 1];\n}\n\nint main() {\n    vector<Job> jobs = {{1, 3, 50}, {2, 4, 10}, {3, 5, 40}, {3, 6, 70}};\n    cout << \"Maximum profit: \" << jobScheduling(jobs) << endl;\n    return 0;\n}",
    "mainImage": "https://res.cloudinary.com/daozctcil/image/upload/v1751439496/ee03750e-16ef-409b-80ce-9c9795414a01.png",
    "slideshowImage": ["https://res.cloudinary.com/daozctcil/image/upload/v1751439511/7ef295f9-6704-45a8-946d-fd8fdafa7c4e.png","https://res.cloudinary.com/daozctcil/image/upload/v1751439514/e854422b-d42e-4b32-b571-ca6df22b3657.png","https://res.cloudinary.com/daozctcil/image/upload/v1751439530/60969598-37e6-49a1-832d-f321af0ce643.png","https://res.cloudinary.com/daozctcil/image/upload/v1751439547/cb680082-3895-434c-b090-3fd766a659a7.png"],
    "category": [
      "Dynamic & Greedy"
    ]
  },
  {
    "number": 29,
    "times_viewed": 0,
    "id": "huffman_encoding",
    "name": "Huffman Encoding",
    "description": "Huffman Encoding is a greedy algorithm used for lossless data compression by assigning variable-length binary codes to input characters based on their frequencies.\n\nExplaination:\nWe create a min-heap of all characters based on their frequencies. The two lowest-frequency nodes are extracted and combined into a new internal node with their combined frequency. This process is repeated until one node remains, forming the root of the Huffman tree. Codes are assigned by traversing the tree: '0' for left and '1' for right. This method ensures that more frequent characters have shorter codes, reducing the total encoded length.\n\nTime Complexity:\n- O(n log n), where n is the number of unique characters\n\nSpace Complexity: O(n)",
    "java": "import java.util.*;\nclass Node {\n    char ch;\n    int freq;\n    Node left, right;\n    Node(char ch, int freq) {\n        this.ch = ch;\n        this.freq = freq;\n    }\n    Node(int freq, Node left, Node right) {\n        this.ch = '\\0';\n        this.freq = freq;\n        this.left = left;\n        this.right = right;\n    }\n}\n\npublic class HuffmanEncoding {\n    public static void printCodes(Node root, String code) {\n        if (root == null) return;\n        if (root.left == null && root.right == null)\n            System.out.println(root.ch + \": \" + code);\n        printCodes(root.left, code + \"0\");\n        printCodes(root.right, code + \"1\");\n    }\n\n    public static void main(String[] args) {\n        char[] chars = {'a', 'b', 'c', 'd', 'e', 'f'};\n        int[] freqs = {5, 9, 12, 13, 16, 45};\n        PriorityQueue<Node> pq = new PriorityQueue<>(Comparator.comparingInt(n -> n.freq));\n        for (int i = 0; i < chars.length; i++)\n            pq.add(new Node(chars[i], freqs[i]));\n        while (pq.size() > 1) {\n            Node left = pq.poll();\n            Node right = pq.poll();\n            pq.add(new Node(left.freq + right.freq, left, right));\n        }\n        Node root = pq.poll();\n        printCodes(root, \"\");\n    }\n}",
    "python": "import heapq\nclass Node:\n    def __init__(self, char, freq):\n        self.char = char\n        self.freq = freq\n        self.left = None\n        self.right = None\n    def __lt__(self, other):\n        return self.freq < other.freq\n\ndef print_codes(node, code):\n    if node:\n        if not node.left and not node.right:\n            print(f''{node.char}: {code}'')\n        print_codes(node.left, code + '0')\n        print_codes(node.right, code + '1')\n\nchars = ['a', 'b', 'c', 'd', 'e', 'f']\nfreqs = [5, 9, 12, 13, 16, 45]\nheap = [Node(chars[i], freqs[i]) for i in range(len(chars))]\nheapq.heapify(heap)\nwhile len(heap) > 1:\n    left = heapq.heappop(heap)\n    right = heapq.heappop(heap)\n    merged = Node(None, left.freq + right.freq)\n    merged.left = left\n    merged.right = right\n    heapq.heappush(heap, merged)\nroot = heap[0]\nprint_codes(root, '')",
    "cpp": "#include <iostream>\n#include <queue>\n#include <vector>\nusing namespace std;\n\nstruct Node {\n    char ch;\n    int freq;\n    Node* left;\n    Node* right;\n    Node(char ch, int freq) : ch(ch), freq(freq), left(nullptr), right(nullptr) {}\n    Node(int freq, Node* l, Node* r) : ch('\\0'), freq(freq), left(l), right(r) {}\n};\n\nstruct Compare {\n    bool operator()(Node* a, Node* b) {\n        return a->freq > b->freq;\n    }\n};\n\nvoid printCodes(Node* root, string code) {\n    if (!root) return;\n    if (!root->left && !root->right)\n        cout << root->ch << \": \" << code << endl;\n    printCodes(root->left, code + \"0\");\n    printCodes(root->right, code + \"1\");\n}\n\nint main() {\n    vector<char> chars = {'a', 'b', 'c', 'd', 'e', 'f'};\n    vector<int> freqs = {5, 9, 12, 13, 16, 45};\n    priority_queue<Node*, vector<Node*>, Compare> pq;\n    for (int i = 0; i < chars.size(); i++)\n        pq.push(new Node(chars[i], freqs[i]));\n    while (pq.size() > 1) {\n        Node* left = pq.top(); pq.pop();\n        Node* right = pq.top(); pq.pop();\n        pq.push(new Node(left->freq + right->freq, left, right));\n    }\n    Node* root = pq.top();\n    printCodes(root, \"\");\n    return 0;\n}",
    "mainImage": "https://res.cloudinary.com/daozctcil/image/upload/v1751439685/a3e02477-e798-46fe-90a8-145171ec633d.png",
    "slideshowImage": ["https://res.cloudinary.com/daozctcil/image/upload/v1751439710/de3699a5-2ef7-4006-941c-25d008690d25.png","https://res.cloudinary.com/daozctcil/image/upload/v1751439734/65764d34-51ab-49e4-9e5e-f00e9dc15f11.png","https://res.cloudinary.com/daozctcil/image/upload/v1751439760/c534ea34-7962-4cb1-b013-2f6e3a159a5d.png","https://res.cloudinary.com/daozctcil/image/upload/v1751439768/76303f22-f45e-4bb7-b07a-87ff21b732ba.png","https://res.cloudinary.com/daozctcil/image/upload/v1751439771/6f5ad556-601f-4177-a3b9-6b6d6bb6fdde.png","https://res.cloudinary.com/daozctcil/image/upload/v1751439685/a3e02477-e798-46fe-90a8-145171ec633d.png","https://res.cloudinary.com/daozctcil/image/upload/v1751439823/0c1f30fb-4db6-49fe-80fa-1d44707f238d.png"],
    "category": [
      "Dynamic & Greedy"
    ]
  },
  {
    "number": 30,
    "times_viewed": 0,
    "id": "dijkstras_algorithm",
    "name": "Dijkstra Algorithm",
    "description": "Dijkstra's Algorithm is a greedy algorithm used to find the shortest path from a source vertex to all other vertices in a weighted, non-negative graph.\n\nExplaination:\nWe maintain a min-priority queue (or min-heap) to always expand the vertex with the smallest tentative distance. A distance array dist[] is initialized to infinity for all vertices except the source, which is 0. For each extracted vertex, we update the distances of its neighbors if a shorter path is found. This continues until all vertices are processed. Dijkstra is widely used in routing and GPS systems.\n\nTime Complexity:\n- O((V + E) log V) using a priority queue\n\nSpace Complexity: O(V)",
    "java": "import java.util.*;\nclass Pair {\n    int vertex, weight;\n    Pair(int v, int w) {\n        vertex = v;\n        weight = w;\n    }\n}\n\npublic class Dijkstra {\n    public static void dijkstra(List<List<Pair>> graph, int src) {\n        int V = graph.size();\n        int[] dist = new int[V];\n        Arrays.fill(dist, Integer.MAX_VALUE);\n        dist[src] = 0;\n        PriorityQueue<Pair> pq = new PriorityQueue<>(Comparator.comparingInt(p -> p.weight));\n        pq.offer(new Pair(src, 0));\n        while (!pq.isEmpty()) {\n            Pair current = pq.poll();\n            int u = current.vertex;\n            for (Pair neighbor : graph.get(u)) {\n                int v = neighbor.vertex;\n                int w = neighbor.weight;\n                if (dist[u] + w < dist[v]) {\n                    dist[v] = dist[u] + w;\n                    pq.offer(new Pair(v, dist[v]));\n                }\n            }\n        }\n        for (int i = 0; i < V; i++) {\n            System.out.println(\"Distance to vertex \" + i + \": \" + dist[i]);\n        }\n    }\n\n    public static void main(String[] args) {\n        int V = 5;\n        List<List<Pair>> graph = new ArrayList<>();\n        for (int i = 0; i < V; i++) graph.add(new ArrayList<>());\n        graph.get(0).add(new Pair(1, 10));\n        graph.get(0).add(new Pair(4, 3));\n        graph.get(1).add(new Pair(2, 2));\n        graph.get(1).add(new Pair(4, 4));\n        graph.get(2).add(new Pair(3, 9));\n        graph.get(3).add(new Pair(2, 7));\n        graph.get(4).add(new Pair(1, 1));\n        graph.get(4).add(new Pair(2, 8));\n        dijkstra(graph, 0);\n    }\n}}",
    "python": "import heapq\n\ndef dijkstra(graph, src):\n    V = len(graph)\n    dist = [float('inf')] * V\n    dist[src] = 0\n    pq = [(0, src)]\n    while pq:\n        d, u = heapq.heappop(pq)\n        for v, w in graph[u]:\n            if dist[u] + w < dist[v]:\n                dist[v] = dist[u] + w\n                heapq.heappush(pq, (dist[v], v))\n    for i in range(V):\n        print(f''Distance to vertex {i}: {dist[i]}'')\n\ngraph = {\n    0: [(1, 10), (4, 3)],\n    1: [(2, 2), (4, 4)],\n    2: [(3, 9)],\n    3: [(2, 7)],\n    4: [(1, 1), (2, 8)]\n}\ndijkstra(graph, 0)",
    "cpp": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <utility>\nusing namespace std;\n\ntypedef pair<int, int> pii;\n\nvoid dijkstra(vector<vector<pii>>& graph, int src) {\n    int V = graph.size();\n    vector<int> dist(V, INT_MAX);\n    dist[src] = 0;\n    priority_queue<pii, vector<pii>, greater<pii>> pq;\n    pq.push({0, src});\n    while (!pq.empty()) {\n        int u = pq.top().second;\n        pq.pop();\n        for (auto& [v, w] : graph[u]) {\n            if (dist[u] + w < dist[v]) {\n                dist[v] = dist[u] + w;\n                pq.push({dist[v], v});\n            }\n        }\n    }\n    for (int i = 0; i < V; i++) {\n        cout << \"Distance to vertex \" << i << \": \" << dist[i] << endl;\n    }\n}\n\nint main() {\n    int V = 5;\n    vector<vector<pii>> graph(V);\n    graph[0] = {{1, 10}, {4, 3}};\n    graph[1] = {{2, 2}, {4, 4}};\n    graph[2] = {{3, 9}};\n    graph[3] = {{2, 7}};\n    graph[4] = {{1, 1}, {2, 8}};\n    dijkstra(graph, 0);\n    return 0;\n}",
    "mainImage": "https://res.cloudinary.com/daozctcil/image/upload/v1751439881/ec642b7e-adf3-44fb-b853-403a72334f5c.png",
    "slideshowImage": ["https://res.cloudinary.com/daozctcil/image/upload/v1751439930/4a54d7e1-f334-4f10-8238-5ef288ade31a.png","https://res.cloudinary.com/daozctcil/image/upload/v1751439946/0ddf0934-1f1b-43ae-b264-df25ad486294.png","https://res.cloudinary.com/daozctcil/image/upload/v1751439975/702421f5-f080-4389-9abb-26c4a5b2ffad.png","https://res.cloudinary.com/daozctcil/image/upload/v1751439964/12e04c62-08c9-4eab-b1af-6ce7b74da225.png","https://res.cloudinary.com/daozctcil/image/upload/v1751439979/692d0495-fb43-4bae-a059-5455ada9d0cb.png","https://res.cloudinary.com/daozctcil/image/upload/v1751439982/2720d707-a9a1-46a0-8321-7e8567f1c452.png","https://res.cloudinary.com/daozctcil/image/upload/v1751439985/d174a8c8-a335-49f0-b1ce-972fc2f33b6a.png"],
    "category": [
      "Dynamic & Greedy"
    ]
  },
  {
    "number": 31,
    "times_viewed": 0,
    "id": "prims_algorithm",
    "name": "Prim Algorithm",
    "description": "Prim's Algorithm is a greedy algorithm used to find the Minimum Spanning Tree (MST) of a connected, weighted, undirected graph by always picking the smallest edge that connects a new vertex to the growing MST.\n\nExplaination:\nPrim's algorithm starts with an arbitrary vertex and grows the MST one edge at a time by always choosing the edge with the smallest weight that connects a vertex in the MST to a vertex outside it. A priority queue (min-heap) is typically used to efficiently find the minimum weight edge. This continues until all vertices are included in the MST. It ensures that the total weight of the tree is minimized without forming cycles.\n\nTime Complexity:\n- O(E log V) using a priority queue\n\nSpace Complexity: O(V)",
    "java": "import java.util.*;\nclass Edge {\n    int vertex, weight;\n    Edge(int v, int w) {\n        vertex = v;\n        weight = w;\n    }\n}\n\npublic class PrimAlgorithm {\n    public static void primMST(List<List<Edge>> graph, int V) {\n        boolean[] visited = new boolean[V];\n        PriorityQueue<Edge> pq = new PriorityQueue<>(Comparator.comparingInt(e -> e.weight));\n        pq.offer(new Edge(0, 0));\n        int totalWeight = 0;\n        while (!pq.isEmpty()) {\n            Edge curr = pq.poll();\n            if (visited[curr.vertex]) continue;\n            visited[curr.vertex] = true;\n            totalWeight += curr.weight;\n            for (Edge neighbor : graph.get(curr.vertex)) {\n                if (!visited[neighbor.vertex])\n                    pq.offer(new Edge(neighbor.vertex, neighbor.weight));\n            }\n        }\n        System.out.println(\"Total weight of MST: \" + totalWeight);\n    }\n\n    public static void main(String[] args) {\n        int V = 5;\n        List<List<Edge>> graph = new ArrayList<>();\n        for (int i = 0; i < V; i++) graph.add(new ArrayList<>());\n        graph.get(0).add(new Edge(1, 2));\n        graph.get(0).add(new Edge(3, 6));\n        graph.get(1).add(new Edge(0, 2));\n        graph.get(1).add(new Edge(2, 3));\n        graph.get(1).add(new Edge(3, 8));\n        graph.get(1).add(new Edge(4, 5));\n        graph.get(2).add(new Edge(1, 3));\n        graph.get(2).add(new Edge(4, 7));\n        graph.get(3).add(new Edge(0, 6));\n        graph.get(3).add(new Edge(1, 8));\n        graph.get(4).add(new Edge(1, 5));\n        graph.get(4).add(new Edge(2, 7));\n        primMST(graph, V);\n    }\n}",
    "python": "import heapq\n\ndef prim_mst(graph, V):\n    visited = [False] * V\n    min_heap = [(0, 0)]\n    total_weight = 0\n    while min_heap:\n        weight, u = heapq.heappop(min_heap)\n        if visited[u]:\n            continue\n        visited[u] = True\n        total_weight += weight\n        for v, w in graph[u]:\n            if not visited[v]:\n                heapq.heappush(min_heap, (w, v))\n    print(f''Total weight of MST: {total_weight}'')\n\ngraph = {\n    0: [(1, 2), (3, 6)],\n    1: [(0, 2), (2, 3), (3, 8), (4, 5)],\n    2: [(1, 3), (4, 7)],\n    3: [(0, 6), (1, 8)],\n    4: [(1, 5), (2, 7)]\n}\nprim_mst(graph, 5)",
    "cpp": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <utility>\nusing namespace std;\n\ntypedef pair<int, int> pii;\n\nvoid primMST(vector<vector<pii>>& graph, int V) {\n    vector<bool> visited(V, false);\n    priority_queue<pii, vector<pii>, greater<pii>> pq;\n    pq.push({0, 0});\n    int totalWeight = 0;\n    while (!pq.empty()) {\n        auto [weight, u] = pq.top();\n        pq.pop();\n        if (visited[u]) continue;\n        visited[u] = true;\n        totalWeight += weight;\n        for (auto& [v, w] : graph[u]) {\n            if (!visited[v]) {\n                pq.push({w, v});\n            }\n        }\n    }\n    cout << \"Total weight of MST: \" << totalWeight << endl;\n}\n\nint main() {\n    int V = 5;\n    vector<vector<pii>> graph(V);\n    graph[0] = {{1, 2}, {3, 6}};\n    graph[1] = {{0, 2}, {2, 3}, {3, 8}, {4, 5}};\n    graph[2] = {{1, 3}, {4, 7}};\n    graph[3] = {{0, 6}, {1, 8}};\n    graph[4] = {{1, 5}, {2, 7}};\n    primMST(graph, V);\n    return 0;\n}",
    "mainImage": "https://res.cloudinary.com/daozctcil/image/upload/v1751440120/370b5c43-84a3-4cdc-b566-6a725d46973d.png",
    "slideshowImage": ["https://res.cloudinary.com/daozctcil/image/upload/v1751440134/5fe7c06c-7b4b-4465-97f5-ab86567261de.png","https://res.cloudinary.com/daozctcil/image/upload/v1751440172/43723094-231e-4c2f-ba4d-0a87f7f114c8.png","https://res.cloudinary.com/daozctcil/image/upload/v1751440176/95e995a7-1538-4fca-88ba-a7afe52fc88f.png","https://res.cloudinary.com/daozctcil/image/upload/v1751440169/1f2a753f-8309-4544-b41e-3d52e8213d91.png","https://res.cloudinary.com/daozctcil/image/upload/v1751440198/8bc31990-36bb-4cc5-a166-8e3ed9a4f635.png","https://res.cloudinary.com/daozctcil/image/upload/v1751440211/f905637c-60b9-4bb0-afc2-fd11550c3392.png","https://res.cloudinary.com/daozctcil/image/upload/v1751440227/74e67b5a-43dc-42e9-b680-b1fc58cade00.png","https://res.cloudinary.com/daozctcil/image/upload/v1751440241/5a6834b0-6db7-4203-99ea-966761580b98.png","https://res.cloudinary.com/daozctcil/image/upload/v1751440247/34af8297-030b-4145-8054-a6aefb216c84.png","https://res.cloudinary.com/daozctcil/image/upload/v1751440254/fcf87f21-093c-4bf3-a34f-7cfc9b4a5ae8.png","https://res.cloudinary.com/daozctcil/image/upload/v1751440258/2471d03a-ca7d-4493-aef2-5dbdb5b56639.png"],
    "category": [
      "Dynamic & Greedy"
    ]
  },
  {
    "number": 32,
    "times_viewed": 0,
    "id": "bellman_ford_algorithm",
    "name": "Bellman-Ford Algorithm",
    "description": "The Bellman-Ford algorithm finds the shortest path from a single source to all other vertices in a weighted graph, even if it contains negative weight edges.\n\nExplaination:\nBellman-Ford initializes the distance to the source as 0 and all others as infinity. Then it relaxes all edges V−1 times (where V is the number of vertices), updating the distance if a shorter path is found. After all relaxations, one more pass checks for negative weight cycles. If any distance updates in the final pass, a negative cycle exists. Unlike Dijkstra, Bellman-Ford can handle negative weights and detect cycles.\n\nTime Complexity:\n- O(V × E)\n\nSpace Complexity: O(V)",
    "java": "import java.util.*;\nclass Edge {\n    int u, v, w;\n    Edge(int u, int v, int w) {\n        this.u = u;\n        this.v = v;\n        this.w = w;\n    }\n}\n\npublic class BellmanFord {\n    public static void bellmanFord(List<Edge> edges, int V, int src) {\n        int[] dist = new int[V];\n        Arrays.fill(dist, Integer.MAX_VALUE);\n        dist[src] = 0;\n        for (int i = 1; i < V; i++) {\n            for (Edge e : edges) {\n                if (dist[e.u] != Integer.MAX_VALUE && dist[e.u] + e.w < dist[e.v])\n                    dist[e.v] = dist[e.u] + e.w;\n            }\n        }\n        for (Edge e : edges) {\n            if (dist[e.u] != Integer.MAX_VALUE && dist[e.u] + e.w < dist[e.v]) {\n                System.out.println(\"Negative weight cycle detected\");\n                return;\n            }\n        }\n        for (int i = 0; i < V; i++) {\n            System.out.println(\"Distance to vertex \" + i + \": \" + dist[i]);\n        }\n    }\n\n    public static void main(String[] args) {\n        int V = 5;\n        List<Edge> edges = Arrays.asList(\n            new Edge(0, 1, -1), new Edge(0, 2, 4),\n            new Edge(1, 2, 3), new Edge(1, 3, 2), new Edge(1, 4, 2),\n            new Edge(3, 2, 5), new Edge(3, 1, 1), new Edge(4, 3, -3)\n        );\n        bellmanFord(edges, V, 0);\n    }\n}}",
    "python": "def bellman_ford(edges, V, src):\n    dist = [float('inf')] * V\n    dist[src] = 0\n    for _ in range(V - 1):\n        for u, v, w in edges:\n            if dist[u] != float('inf') and dist[u] + w < dist[v]:\n                dist[v] = dist[u] + w\n    for u, v, w in edges:\n        if dist[u] != float('inf') and dist[u] + w < dist[v]:\n            print(''Negative weight cycle detected'')\n            return\n    for i in range(V):\n        print(f''Distance to vertex {i}: {dist[i]}'')\n\nedges = [\n    (0, 1, -1), (0, 2, 4),\n    (1, 2, 3), (1, 3, 2), (1, 4, 2),\n    (3, 2, 5), (3, 1, 1), (4, 3, -3)\n]\nbellman_ford(edges, 5, 0)",
    "cpp": "#include <iostream>\n#include <vector>\n#include <climits>\nusing namespace std;\n\nstruct Edge {\n    int u, v, w;\n};\n\nvoid bellmanFord(vector<Edge>& edges, int V, int src) {\n    vector<int> dist(V, INT_MAX);\n    dist[src] = 0;\n    for (int i = 1; i < V; i++) {\n        for (auto& e : edges) {\n            if (dist[e.u] != INT_MAX && dist[e.u] + e.w < dist[e.v])\n                dist[e.v] = dist[e.u] + e.w;\n        }\n    }\n    for (auto& e : edges) {\n        if (dist[e.u] != INT_MAX && dist[e.u] + e.w < dist[e.v]) {\n            cout << \"Negative weight cycle detected\" << endl;\n            return;\n        }\n    }\n    for (int i = 0; i < V; i++) {\n        cout << \"Distance to vertex \" << i << \": \" << dist[i] << endl;\n    }\n}\n\nint main() {\n    int V = 5;\n    vector<Edge> edges = {\n        {0, 1, -1}, {0, 2, 4},\n        {1, 2, 3}, {1, 3, 2}, {1, 4, 2},\n        {3, 2, 5}, {3, 1, 1}, {4, 3, -3}\n    };\n    bellmanFord(edges, V, 0);\n    return 0;\n}",
    "mainImage": "https://res.cloudinary.com/daozctcil/image/upload/v1751440378/265d8d71-d3f5-433b-b946-ed9f666f5975.png",
    "slideshowImage": ["https://res.cloudinary.com/daozctcil/image/upload/v1751440406/6851893c-c8cf-4bd1-92f2-49f8714ec1ea.png","https://res.cloudinary.com/daozctcil/image/upload/v1751440429/1733fe90-ee5f-46c4-a2f0-273e03123481.png","https://res.cloudinary.com/daozctcil/image/upload/v1751440447/600d0fe8-e951-43f4-a01e-08ef862100bc.png","https://res.cloudinary.com/daozctcil/image/upload/v1751440460/ae84c82b-5c07-431d-9e1c-d7557a5ba58b.png","https://res.cloudinary.com/daozctcil/image/upload/v1751440455/01e9a74e-35a6-445b-86a7-15876f9c7a3d.png","https://res.cloudinary.com/daozctcil/image/upload/v1751440467/02ce1941-93a4-4b00-bb5d-9b0e9d741b32.png"],
    "category": [
      "Dynamic & Greedy"
    ]
  },
  {
    "number": 33,
    "times_viewed": 0,
    "id": "kruskals_algorithm",
    "name": "Kruskal Algorithm",
    "description": "Kruskal's Algorithm is a greedy algorithm used to find the Minimum Spanning Tree (MST) by selecting the edges in increasing order of weight and adding them if they don't form a cycle.\n\nExplaination:\nKruskal’s algorithm sorts all edges of the graph by weight. Then, it picks the smallest edge and adds it to the MST if it doesn’t form a cycle, using the Union-Find (Disjoint Set Union) data structure to track connected components. This continues until the MST contains exactly V−1 edges. It is efficient for sparse graphs and ensures the MST has the minimum total weight.\n\nTime Complexity:\n- O(E log E), due to sorting edges\n\nSpace Complexity: O(V)",
    "java": "import java.util.*;\nclass Edge {\n    int u, v, weight;\n    Edge(int u, int v, int w) {\n        this.u = u; this.v = v; this.weight = w;\n    }\n}\n\npublic class Kruskal {\n    static int find(int[] parent, int x) {\n        if (parent[x] != x) parent[x] = find(parent, parent[x]);\n        return parent[x];\n    }\n\n    static void union(int[] parent, int[] rank, int x, int y) {\n        int rootX = find(parent, x);\n        int rootY = find(parent, y);\n        if (rootX != rootY) {\n            if (rank[rootX] < rank[rootY])\n                parent[rootX] = rootY;\n            else if (rank[rootX] > rank[rootY])\n                parent[rootY] = rootX;\n            else {\n                parent[rootY] = rootX;\n                rank[rootX]++;\n            }\n        }\n    }\n\n    public static void kruskal(List<Edge> edges, int V) {\n        Collections.sort(edges, Comparator.comparingInt(e -> e.weight));\n        int[] parent = new int[V];\n        int[] rank = new int[V];\n        for (int i = 0; i < V; i++) parent[i] = i;\n        int totalWeight = 0;\n        for (Edge e : edges) {\n            if (find(parent, e.u) != find(parent, e.v)) {\n                union(parent, rank, e.u, e.v);\n                totalWeight += e.weight;\n            }\n        }\n        System.out.println(\"Total weight of MST: \" + totalWeight);\n    }\n\n    public static void main(String[] args) {\n        List<Edge> edges = Arrays.asList(\n            new Edge(0, 1, 10), new Edge(0, 2, 6), new Edge(0, 3, 5),\n            new Edge(1, 3, 15), new Edge(2, 3, 4)\n        );\n        kruskal(edges, 4);\n    }\n}",
    "python": "class DisjointSet:\n    def __init__(self, n):\n        self.parent = list(range(n))\n        self.rank = [0] * n\n\n    def find(self, x):\n        if self.parent[x] != x:\n            self.parent[x] = self.find(self.parent[x])\n        return self.parent[x]\n\n    def union(self, x, y):\n        xroot = self.find(x)\n        yroot = self.find(y)\n        if xroot != yroot:\n            if self.rank[xroot] < self.rank[yroot]:\n                self.parent[xroot] = yroot\n            elif self.rank[xroot] > self.rank[yroot]:\n                self.parent[yroot] = xroot\n            else:\n                self.parent[yroot] = xroot\n                self.rank[xroot] += 1\n\ndef kruskal(edges, V):\n    ds = DisjointSet(V)\n    edges.sort(key=lambda x: x[2])\n    total_weight = 0\n    for u, v, w in edges:\n        if ds.find(u) != ds.find(v):\n            ds.union(u, v)\n            total_weight += w\n    print(f''Total weight of MST: {total_weight}'')\n\nedges = [(0, 1, 10), (0, 2, 6), (0, 3, 5), (1, 3, 15), (2, 3, 4)]\nkruskal(edges, 4)",
    "cpp": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nstruct Edge {\n    int u, v, w;\n};\n\nint find(vector<int>& parent, int x) {\n    if (parent[x] != x) parent[x] = find(parent, parent[x]);\n    return parent[x];\n}\n\nvoid unionSet(vector<int>& parent, vector<int>& rank, int x, int y) {\n    int rootX = find(parent, x);\n    int rootY = find(parent, y);\n    if (rootX != rootY) {\n        if (rank[rootX] < rank[rootY]) parent[rootX] = rootY;\n        else if (rank[rootX] > rank[rootY]) parent[rootY] = rootX;\n        else {\n            parent[rootY] = rootX;\n            rank[rootX]++;\n        }\n    }\n}\n\nvoid kruskal(vector<Edge>& edges, int V) {\n    sort(edges.begin(), edges.end(), [](Edge a, Edge b) {\n        return a.w < b.w;\n    });\n    vector<int> parent(V), rank(V, 0);\n    for (int i = 0; i < V; i++) parent[i] = i;\n    int totalWeight = 0;\n    for (auto& e : edges) {\n        if (find(parent, e.u) != find(parent, e.v)) {\n            unionSet(parent, rank, e.u, e.v);\n            totalWeight += e.w;\n        }\n    }\n    cout << \"Total weight of MST: \" << totalWeight << endl;\n}\n\nint main() {\n    vector<Edge> edges = {\n        {0, 1, 10}, {0, 2, 6}, {0, 3, 5}, {1, 3, 15}, {2, 3, 4}\n    };\n    kruskal(edges, 4);\n    return 0;\n}",
    "mainImage": "https://res.cloudinary.com/daozctcil/image/upload/v1751440548/3b540cb3-dfb6-4297-aea8-e163cf98fbd8.png",
    "slideshowImage": ["https://res.cloudinary.com/daozctcil/image/upload/v1751440548/3b540cb3-dfb6-4297-aea8-e163cf98fbd8.png","https://res.cloudinary.com/daozctcil/image/upload/v1751440578/917b8206-5104-4b86-986f-bac526abc841.png","https://res.cloudinary.com/daozctcil/image/upload/v1751440591/9f56ac2f-aa8d-4cbe-b553-3d754b424faa.png","https://res.cloudinary.com/daozctcil/image/upload/v1751440630/5650419b-3a3f-47fc-88e1-6d549e91397c.png","https://res.cloudinary.com/daozctcil/image/upload/v1751440635/2d67a843-8014-46c2-8ff8-c018adcdf5c9.png","https://res.cloudinary.com/daozctcil/image/upload/v1751440608/2a4fef1b-7fea-49ee-8818-f509b6eaae45.png","https://res.cloudinary.com/daozctcil/image/upload/v1751440639/02bd9864-52c3-401e-a2bb-a6828d2ff9d3.png","https://res.cloudinary.com/daozctcil/image/upload/v1751440643/96e2ec07-8136-499f-a7df-80127296ad9b.png","https://res.cloudinary.com/daozctcil/image/upload/v1751440653/fdec50d9-2f89-44ad-94c8-814a9ad43333.png","https://res.cloudinary.com/daozctcil/image/upload/v1751440661/3afe7a22-dadb-4818-b444-67dafd798259.png"],
    "category": [
      "Dynamic & Greedy"
    ]
  },
  {
    "number": 34,
    "times_viewed": 0,
    "id": "depth_first_search",
    "name": "Depth First Search",
    "description": "Depth First Search (DFS) is a graph traversal algorithm that explores as far as possible along each branch before backtracking, using recursion or a stack.\n\nExplaination:\nDFS starts at a source vertex and explores each branch completely before moving to the next branch. It uses a visited array to avoid cycles and redundant visits. DFS can be implemented using recursion or an explicit stack. It is commonly used in pathfinding, cycle detection, topological sorting, and connected component analysis.\n\nTime Complexity:\n- O(V + E), where V = vertices, E = edges\n\nSpace Complexity: O(V) (for visited and recursion stack)",
    "java": "import java.util.*;\npublic class DFS {\n    public static void dfs(int node, List<List<Integer>> graph, boolean[] visited) {\n        visited[node] = true;\n        System.out.print(node + \" \");\n        for (int neighbor : graph.get(node)) {\n            if (!visited[neighbor]) {\n                dfs(neighbor, graph, visited);\n            }\n        }\n    }\n\n    public static void main(String[] args) {\n        int V = 5;\n        List<List<Integer>> graph = new ArrayList<>();\n        for (int i = 0; i < V; i++) graph.add(new ArrayList<>());\n        graph.get(0).add(1);\n        graph.get(0).add(2);\n        graph.get(1).add(3);\n        graph.get(1).add(4);\n        boolean[] visited = new boolean[V];\n        System.out.print(\"DFS traversal: \");\n        dfs(0, graph, visited);\n    }\n}",
    "python": "def dfs(node, graph, visited):\n    visited[node] = True\n    print(node, end=' ')\n    for neighbor in graph[node]:\n        if not visited[neighbor]:\n            dfs(neighbor, graph, visited)\n\ngraph = {\n    0: [1, 2],\n    1: [3, 4],\n    2: [],\n    3: [],\n    4: []\n}\nvisited = [False] * 5\nprint('DFS traversal:', end=' ')\ndfs(0, graph, visited)",
    "cpp": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nvoid dfs(int node, vector<vector<int>>& graph, vector<bool>& visited) {\n    visited[node] = true;\n    cout << node << \" \";\n    for (int neighbor : graph[node]) {\n        if (!visited[neighbor]) {\n            dfs(neighbor, graph, visited);\n        }\n    }\n}\n\nint main() {\n    int V = 5;\n    vector<vector<int>> graph(V);\n    graph[0] = {1, 2};\n    graph[1] = {3, 4};\n    vector<bool> visited(V, false);\n    cout << \"DFS traversal: \";\n    dfs(0, graph, visited);\n    return 0;\n}",
    "mainImage": "https://res.cloudinary.com/daozctcil/image/upload/v1751440834/a2c9af10-ba83-405a-9c15-fb317e644872.png",
    "slideshowImage": ["https://res.cloudinary.com/daozctcil/image/upload/v1751440873/9857aa5d-4ef9-4cd1-ab93-7777069980d2.png","https://res.cloudinary.com/daozctcil/image/upload/v1751440951/4fd5e3b7-687b-49ce-8331-ae591940950b.png","https://res.cloudinary.com/daozctcil/image/upload/v1751440965/56d600d3-b03d-4e5e-94c5-068cd22777a4.png","https://res.cloudinary.com/daozctcil/image/upload/v1751440900/41a4068a-1c71-476f-9bd9-0ff0bd455791.png","https://res.cloudinary.com/daozctcil/image/upload/v1751440974/ca8ae08d-e6be-444e-90de-ce114134458f.png","https://res.cloudinary.com/daozctcil/image/upload/v1751440981/d58fc3a0-f15d-447f-9b39-b7dc88b2af12.png","https://res.cloudinary.com/daozctcil/image/upload/v1751440992/099ae56a-ca3e-4e2a-84d1-d516b1d185f1.png","https://res.cloudinary.com/daozctcil/image/upload/v1751440999/7478dd4a-5037-452b-afab-5334e347196a.png","https://res.cloudinary.com/daozctcil/image/upload/v1751441006/272f146f-5005-44c9-a69c-de9139e4822b.png","https://res.cloudinary.com/daozctcil/image/upload/v1751441008/2bb5dc7c-e118-4951-89c3-a380481fd513.png"],
    "category": [
      "Graph & Tree"
    ]
  },
  {
    "number": 35,
    "times_viewed": 0,
    "id": "breadth_first_search",
    "name": "Breadth First Search",
    "description": "Breadth First Search (BFS) is a graph traversal algorithm that explores all neighbors at the current depth before moving on to nodes at the next level using a queue.\n\nExplaination:\nBFS starts from a source vertex and visits all of its adjacent vertices before going deeper into the graph. It uses a queue to keep track of the current frontier and a visited array to avoid revisiting nodes. BFS is ideal for finding the shortest path in an unweighted graph and is used in many applications like web crawling, network broadcasting, and pathfinding in games.\n\nTime Complexity:\n- O(V + E), where V = number of vertices and E = number of edges\n\nSpace Complexity: O(V) (for visited array and queue)",
    "java": "import java.util.*;\npublic class BFS {\n    public static void bfs(int start, List<List<Integer>> graph, boolean[] visited) {\n        Queue<Integer> queue = new LinkedList<>();\n        queue.offer(start);\n        visited[start] = true;\n        while (!queue.isEmpty()) {\n            int node = queue.poll();\n            System.out.print(node + \" \");\n            for (int neighbor : graph.get(node)) {\n                if (!visited[neighbor]) {\n                    visited[neighbor] = true;\n                    queue.offer(neighbor);\n                }\n            }\n        }\n    }\n\n    public static void main(String[] args) {\n        int V = 5;\n        List<List<Integer>> graph = new ArrayList<>();\n        for (int i = 0; i < V; i++) graph.add(new ArrayList<>());\n        graph.get(0).add(1);\n        graph.get(0).add(2);\n        graph.get(1).add(3);\n        graph.get(1).add(4);\n        boolean[] visited = new boolean[V];\n        System.out.print(\"BFS traversal: \");\n        bfs(0, graph, visited);\n    }\n}",
    "python": "from collections import deque\n\ndef bfs(start, graph, visited):\n    queue = deque([start])\n    visited[start] = True\n    while queue:\n        node = queue.popleft()\n        print(node, end=' ')\n        for neighbor in graph[node]:\n            if not visited[neighbor]:\n                visited[neighbor] = True\n                queue.append(neighbor)\n\ngraph = {\n    0: [1, 2],\n    1: [3, 4],\n    2: [],\n    3: [],\n    4: []\n}\nvisited = [False] * 5\nprint('BFS traversal:', end=' ')\nbfs(0, graph, visited)",
    "cpp": "#include <iostream>\n#include <vector>\n#include <queue>\nusing namespace std;\n\nvoid bfs(int start, vector<vector<int>>& graph, vector<bool>& visited) {\n    queue<int> q;\n    q.push(start);\n    visited[start] = true;\n    while (!q.empty()) {\n        int node = q.front();\n        q.pop();\n        cout << node << \" \";\n        for (int neighbor : graph[node]) {\n            if (!visited[neighbor]) {\n                visited[neighbor] = true;\n                q.push(neighbor);\n            }\n        }\n    }\n}\n\nint main() {\n    int V = 5;\n    vector<vector<int>> graph(V);\n    graph[0] = {1, 2};\n    graph[1] = {3, 4};\n    vector<bool> visited(V, false);\n    cout << \"BFS traversal: \";\n    bfs(0, graph, visited);\n    return 0;\n}",
    "mainImage": "https://res.cloudinary.com/daozctcil/image/upload/v1751441202/c089c79b-48c9-44c0-81e7-832a2c3cbfb2.png",
    "slideshowImage": ["https://res.cloudinary.com/daozctcil/image/upload/v1751441256/97003319-8a31-4c9c-acee-34c612e40516.png","https://res.cloudinary.com/daozctcil/image/upload/v1751441279/f788be08-74e3-43a6-a1b9-bff03aba420d.png","https://res.cloudinary.com/daozctcil/image/upload/v1751441288/b302a7fa-73cc-4e89-9a51-fdb54889ace6.png","https://res.cloudinary.com/daozctcil/image/upload/v1751441294/3129bda7-4de0-4714-a15c-ff98085801b3.png","https://res.cloudinary.com/daozctcil/image/upload/v1751441302/9297ff04-b2a8-4692-80b0-2f2fe61e3c9c.png","https://res.cloudinary.com/daozctcil/image/upload/v1751441310/132f78e0-4af2-42ec-a86c-0d0825db2edc.png","https://res.cloudinary.com/daozctcil/image/upload/v1751441316/91432c52-6531-4ecd-82db-f3416d668d92.png","https://res.cloudinary.com/daozctcil/image/upload/v1751441331/21c67f3e-10cd-45fe-abd7-fc0bdaee0ee2.png"],
    "category": [
      "Graph & Tree"
    ]
  },
  {
    "number": 36,
    "times_viewed": 0,
    "id": "topological_sort",
    "name": "Topological Sort",
    "description": "Topological Sort is a linear ordering of vertices in a Directed Acyclic Graph (DAG) such that for every directed edge u → v, vertex u comes before v in the ordering.\n\nExplaination:\nTopological Sort is applicable only to DAGs. It can be implemented using DFS or Kahn’s algorithm (BFS-based). In the DFS approach, we recursively visit all unvisited neighbors and push the current node onto a stack after all its neighbors are processed. Reversing the stack gives the topological order. In Kahn’s algorithm, we repeatedly remove nodes with zero in-degree and update the in-degrees of their neighbors. It is widely used in scheduling tasks, resolving symbol dependencies, and build systems.\n\nTime Complexity:\n- O(V + E)\n\nSpace Complexity: O(V)",
    "java": "import java.util.*;\npublic class TopoSortDFS {\n    public static void dfs(int node, List<List<Integer>> graph, boolean[] visited, Stack<Integer> stack) {\n        visited[node] = true;\n        for (int neighbor : graph.get(node)) {\n            if (!visited[neighbor]) {\n                dfs(neighbor, graph, visited, stack);\n            }\n        }\n        stack.push(node);\n    }\n\n    public static void topologicalSort(int V, List<List<Integer>> graph) {\n        boolean[] visited = new boolean[V];\n        Stack<Integer> stack = new Stack<>();\n        for (int i = 0; i < V; i++) {\n            if (!visited[i]) {\n                dfs(i, graph, visited, stack);\n            }\n        }\n        System.out.print(\"Topological order: \");\n        while (!stack.isEmpty()) {\n            System.out.print(stack.pop() + \" \");\n        }\n    }\n\n    public static void main(String[] args) {\n        int V = 6;\n        List<List<Integer>> graph = new ArrayList<>();\n        for (int i = 0; i < V; i++) graph.add(new ArrayList<>());\n        graph.get(5).add(2);\n        graph.get(5).add(0);\n        graph.get(4).add(0);\n        graph.get(4).add(1);\n        graph.get(2).add(3);\n        graph.get(3).add(1);\n        topologicalSort(V, graph);\n    }\n}",
    "python": "def dfs(node, graph, visited, stack):\n    visited[node] = True\n    for neighbor in graph[node]:\n        if not visited[neighbor]:\n            dfs(neighbor, graph, visited, stack)\n    stack.append(node)\n\ndef topological_sort(V, graph):\n    visited = [False] * V\n    stack = []\n    for i in range(V):\n        if not visited[i]:\n            dfs(i, graph, visited, stack)\n    print('Topological order:', ' '.join(map(str, reversed(stack))))\n\ngraph = {\n    0: [], 1: [], 2: [3], 3: [1], 4: [0, 1], 5: [0, 2]\n}\ntopological_sort(6, graph)",
    "cpp": "#include <iostream>\n#include <vector>\n#include <stack>\nusing namespace std;\n\nvoid dfs(int node, vector<vector<int>>& graph, vector<bool>& visited, stack<int>& st) {\n    visited[node] = true;\n    for (int neighbor : graph[node]) {\n        if (!visited[neighbor]) {\n            dfs(neighbor, graph, visited, st);\n        }\n    }\n    st.push(node);\n}\n\nvoid topologicalSort(int V, vector<vector<int>>& graph) {\n    vector<bool> visited(V, false);\n    stack<int> st;\n    for (int i = 0; i < V; i++) {\n        if (!visited[i]) {\n            dfs(i, graph, visited, st);\n        }\n    }\n    cout << \"Topological order: \";\n    while (!st.empty()) {\n        cout << st.top() << \" \";\n        st.pop();\n    }\n}\n\nint main() {\n    int V = 6;\n    vector<vector<int>> graph(V);\n    graph[5] = {2, 0};\n    graph[4] = {0, 1};\n    graph[2] = {3};\n    graph[3] = {1};\n    topologicalSort(V, graph);\n    return 0;\n}",
    "mainImage": "https://res.cloudinary.com/daozctcil/image/upload/v1751441472/ec0a26a2-fe40-43f1-91fc-fd9b268f5599.png",
    "slideshowImage": ["https://res.cloudinary.com/daozctcil/image/upload/v1751441525/21f4ec21-5fd9-4939-bad9-92e59dff23bf.png","https://res.cloudinary.com/daozctcil/image/upload/v1751441539/79d6d67d-4f4c-4b35-82a2-52f8290a24d2.png","https://res.cloudinary.com/daozctcil/image/upload/v1751441547/8ac8ee31-998e-4ec1-920a-5aed2f2cd5b0.png","https://res.cloudinary.com/daozctcil/image/upload/v1751441568/cc191e7c-f2e2-4963-9ec0-3772ec0d6f1d.png","https://res.cloudinary.com/daozctcil/image/upload/v1751441561/f548d5ab-4250-4178-ae14-ff70032f52b1.png","https://res.cloudinary.com/daozctcil/image/upload/v1751441590/0404849f-634d-4306-8c5a-c75e9ddf53d7.png","https://res.cloudinary.com/daozctcil/image/upload/v1751441610/c1fce313-023f-46c9-a659-3b279afde4fe.png","https://res.cloudinary.com/daozctcil/image/upload/v1751441582/dd1ca3ff-ba48-4312-b424-b860db5afc97.png","https://res.cloudinary.com/daozctcil/image/upload/v1751441623/31f613f4-7e57-41e3-88b7-542a11636b8a.png","https://res.cloudinary.com/daozctcil/image/upload/v1751441626/c80c62b8-8bb2-4f44-8e9a-28696dcea6e6.png","https://res.cloudinary.com/daozctcil/image/upload/v1751441603/aba1ae5a-fb29-44b8-aea1-71dfaa5e41fd.png","https://res.cloudinary.com/daozctcil/image/upload/v1751441629/cbbf3abf-309e-4e9c-adb8-fa84810c40bb.png","https://res.cloudinary.com/daozctcil/image/upload/v1751441620/ad722460-ee2e-4d60-a9ea-65565ee2cfc5.png"],
    "category": [
      "Graph & Tree"
    ]
  },
  {
    "number": 37,
    "times_viewed": 0,
    "id": "minimum_spanning_tree",
    "name": "Minimum Spanning Tree",
    "description": "A Minimum Spanning Tree (MST) is a subset of the edges in a connected, weighted, undirected graph that connects all vertices with the minimum total edge weight and no cycles.\n\nExplaination:\nAn MST connects all vertices of a graph with the least possible total edge weight. It must contain exactly V−1 edges if the graph has V vertices. There are two main algorithms to find an MST:\n1) Prim’s Algorithm — grows the MST one vertex at a time by always adding the smallest edge that connects a new vertex to the MST (uses a priority queue).\n2) Kruskal’s Algorithm — sorts all edges and adds them in order if they don’t form a cycle (uses Union-Find/Disjoint Set).\nMSTs are widely used in network design, clustering, and circuit design.\n\nTime Complexity:\n- Prim’s: O(E log V)\n- Kruskal’s: O(E log E)\n\nSpace Complexity: O(V)",
    "java": "import java.util.*;\nclass Edge {\n    int vertex, weight;\n    Edge(int v, int w) {\n        vertex = v;\n        weight = w;\n    }\n}\n\npublic class PrimMST {\n    public static void prim(List<List<Edge>> graph, int V) {\n        boolean[] visited = new boolean[V];\n        PriorityQueue<Edge> pq = new PriorityQueue<>(Comparator.comparingInt(e -> e.weight));\n        pq.offer(new Edge(0, 0));\n        int totalWeight = 0;\n        while (!pq.isEmpty()) {\n            Edge curr = pq.poll();\n            if (visited[curr.vertex]) continue;\n            visited[curr.vertex] = true;\n            totalWeight += curr.weight;\n            for (Edge neighbor : graph.get(curr.vertex)) {\n                if (!visited[neighbor.vertex]) pq.offer(neighbor);\n            }\n        }\n        System.out.println(\"Total MST weight: \" + totalWeight);\n    }\n\n    public static void main(String[] args) {\n        int V = 5;\n        List<List<Edge>> graph = new ArrayList<>();\n        for (int i = 0; i < V; i++) graph.add(new ArrayList<>());\n        graph.get(0).add(new Edge(1, 2));\n        graph.get(0).add(new Edge(3, 6));\n        graph.get(1).add(new Edge(0, 2));\n        graph.get(1).add(new Edge(2, 3));\n        graph.get(2).add(new Edge(1, 3));\n        graph.get(3).add(new Edge(0, 6));\n        graph.get(3).add(new Edge(4, 9));\n        graph.get(4).add(new Edge(3, 9));\n        prim(graph, V);\n    }\n}",
    "python": "class DisjointSet:\n    def __init__(self, n):\n        self.parent = list(range(n))\n        self.rank = [0] * n\n\n    def find(self, x):\n        if self.parent[x] != x:\n            self.parent[x] = self.find(self.parent[x])\n        return self.parent[x]\n\n    def union(self, x, y):\n        xr = self.find(x)\n        yr = self.find(y)\n        if xr != yr:\n            if self.rank[xr] < self.rank[yr]:\n                self.parent[xr] = yr\n            elif self.rank[xr] > self.rank[yr]:\n                self.parent[yr] = xr\n            else:\n                self.parent[yr] = xr\n                self.rank[xr] += 1\n\ndef kruskal(edges, V):\n    ds = DisjointSet(V)\n    edges.sort(key=lambda x: x[2])\n    total = 0\n    for u, v, w in edges:\n        if ds.find(u) != ds.find(v):\n            ds.union(u, v)\n            total += w\n    print(f''Total MST weight: {total}'')\n\nedges = [(0, 1, 10), (0, 2, 6), (0, 3, 5), (1, 3, 15), (2, 3, 4)]\nkruskal(edges, 4)",
    "cpp": "A Minimum Spanning Tree (MST) is a subset of the edges in a connected, weighted, undirected graph that connects all vertices with the minimum total edge weight and no cycles.\n\nExplaination:\nAn MST connects all vertices of a graph with the least possible total edge weight. It must contain exactly V−1 edges if the graph has V vertices. There are two main algorithms to find an MST:\n1) Prim’s Algorithm — grows the MST one vertex at a time by always adding the smallest edge that connects a new vertex to the MST (uses a priority queue).\n2) Kruskal’s Algorithm — sorts all edges and adds them in order if they don’t form a cycle (uses Union-Find/Disjoint Set).\nMSTs are widely used in network design, clustering, and circuit design.\n\nTime Complexity:\n- Prim’s: O(E log V)\n- Kruskal’s: O(E log E)\n\nSpace Complexity: O(V)",
    "mainImage": "https://res.cloudinary.com/daozctcil/image/upload/v1751441958/23bfc729-2f6a-4fd6-8ede-e07f82a8b3ae.png",
    "slideshowImage": [],
    "category": [
      "Graph & Tree"
    ]
  },
  
  {
    "number": 41,
    "times_viewed": 0,
    "id": "floyd_warshall",
    "name": "Floyd Warshall",
    "description": "The Floyd-Warshall algorithm is a dynamic programming technique used to find the shortest paths between all pairs of vertices in a weighted graph, even with negative edge weights (but no negative cycles).\n\nExplaination:\nFloyd-Warshall uses a 2D distance matrix where dist[i][j] represents the shortest path from vertex i to j. Initially, it holds direct edge weights or infinity. For every vertex k, the algorithm tries to update dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]), meaning we check if going through k provides a shorter path between i and j. This continues for all combinations. It can detect negative cycles if dist[i][i] becomes negative.\n\nTime Complexity:\n- O(V³)\n\nSpace Complexity: O(V²)",
    "java": "public class FloydWarshall {\n    public static void floydWarshall(int[][] graph, int V) {\n        int[][] dist = new int[V][V];\n        for (int i = 0; i < V; i++) {\n            for (int j = 0; j < V; j++) {\n                dist[i][j] = graph[i][j];\n            }\n        }\n        for (int k = 0; k < V; k++) {\n            for (int i = 0; i < V; i++) {\n                for (int j = 0; j < V; j++) {\n                    if (dist[i][k] != Integer.MAX_VALUE && dist[k][j] != Integer.MAX_VALUE)\n                        dist[i][j] = Math.min(dist[i][j], dist[i][k] + dist[k][j]);\n                }\n            }\n        }\n        for (int i = 0; i < V; i++) {\n            for (int j = 0; j < V; j++) {\n                System.out.print((dist[i][j] == Integer.MAX_VALUE ? \"INF\" : dist[i][j]) + \" \");\n            }\n            System.out.println();\n        }\n    }\n\n    public static void main(String[] args) {\n        int INF = Integer.MAX_VALUE;\n        int[][] graph = {\n            {0, 3, INF, 5},\n            {2, 0, INF, 4},\n            {INF, 1, 0, INF},\n            {INF, INF, 2, 0}\n        };\n        floydWarshall(graph, 4);\n    }\n}",
    "python": "def floyd_warshall(graph):\n    V = len(graph)\n    dist = [row[:] for row in graph]\n    for k in range(V):\n        for i in range(V):\n            for j in range(V):\n                if dist[i][k] != float('inf') and dist[k][j] != float('inf'):\n                    dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j])\n    for row in dist:\n        print(' '.join(str(x) if x != float('inf') else 'INF' for x in row))\n\ngraph = [\n    [0, 3, float('inf'), 5],\n    [2, 0, float('inf'), 4],\n    [float('inf'), 1, 0, float('inf')],\n    [float('inf'), float('inf'), 2, 0]\n]\nfloyd_warshall(graph)",
    "cpp": "#include <iostream>\n#include <vector>\n#include <climits>\nusing namespace std;\n\nvoid floydWarshall(vector<vector<int>>& graph, int V) {\n    vector<vector<int>> dist = graph;\n    for (int k = 0; k < V; k++) {\n        for (int i = 0; i < V; i++) {\n            for (int j = 0; j < V; j++) {\n                if (dist[i][k] != INT_MAX && dist[k][j] != INT_MAX)\n                    dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]);\n            }\n        }\n    }\n    for (int i = 0; i < V; i++) {\n        for (int j = 0; j < V; j++) {\n            if (dist[i][j] == INT_MAX)\n                cout << \"INF \";\n            else\n                cout << dist[i][j] << \" \";\n        }\n        cout << endl;\n    }\n}\n\nint main() {\n    int INF = INT_MAX;\n    vector<vector<int>> graph = {\n        {0, 3, INF, 5},\n        {2, 0, INF, 4},\n        {INF, 1, 0, INF},\n        {INF, INF, 2, 0}\n    };\n    floydWarshall(graph, 4);\n    return 0;\n}",
    "mainImage": "https://res.cloudinary.com/daozctcil/image/upload/v1751442240/220f322b-c247-4f1c-b444-dff65cf964d1.png",
    "slideshowImage": ["https://res.cloudinary.com/daozctcil/image/upload/v1751442286/fa31f825-a810-4ea3-aa81-ecac186b0f41.png","https://res.cloudinary.com/daozctcil/image/upload/v1751442293/e1517983-8805-4e0b-8f7b-f09003591758.png","https://res.cloudinary.com/daozctcil/image/upload/v1751442313/3fc6534c-c907-4ea4-a08f-da501aa8f253.png","https://res.cloudinary.com/daozctcil/image/upload/v1751442306/a8c88dae-4bca-4efa-9fa3-aa07c061246a.png","https://res.cloudinary.com/daozctcil/image/upload/v1751442324/f2267485-47f3-4f43-a2c6-b3a7482387d8.png","https://res.cloudinary.com/daozctcil/image/upload/v1751442321/d30005fa-7a9f-4495-a2e2-7101900af766.png","https://res.cloudinary.com/daozctcil/image/upload/v1751442327/579dc9e5-1407-4973-86d6-990f802c010e.png"],
    "category": [
      "Graph & Tree"
    ]
  },
  {
    "number": 43,
    "times_viewed": 0,
    "id": "a*_search",
    "name": "A* Search",
    "description": "A* Search is a best-first search algorithm that finds the shortest path from a start node to a goal node using both actual cost and heuristic to guide its path selection.\n\nExplaination:\nA* Search maintains a priority queue (open set) sorted by the function f(n) = g(n) + h(n), where g(n) is the cost from the start to the current node, and h(n) is the estimated cost from the current node to the goal (heuristic). It always expands the node with the lowest f(n) value. A* guarantees the shortest path if the heuristic is admissible (never overestimates). It is commonly used in pathfinding problems such as maps, games, and robotics.\n\nTime Complexity:\n- O(E), but depends on heuristic quality and branching\n\nSpace Complexity: O(V)",
    "java": "import java.util.*;\nclass Node {\n    int x, y, g, h;\n    Node parent;\n    Node(int x, int y, int g, int h, Node parent) {\n        this.x = x;\n        this.y = y;\n        this.g = g;\n        this.h = h;\n        this.parent = parent;\n    }\n    int f() { return g + h; }\n}\n\npublic class AStarSearch {\n    static int heuristic(int x1, int y1, int x2, int y2) {\n        return Math.abs(x1 - x2) + Math.abs(y1 - y2);\n    }\n\n    public static void aStar(int[][] grid, int[] start, int[] goal) {\n        int rows = grid.length, cols = grid[0].length;\n        boolean[][] visited = new boolean[rows][cols];\n        PriorityQueue<Node> pq = new PriorityQueue<>(Comparator.comparingInt(Node::f));\n        pq.offer(new Node(start[0], start[1], 0, heuristic(start[0], start[1], goal[0], goal[1]), null));\n        while (!pq.isEmpty()) {\n            Node curr = pq.poll();\n            if (curr.x == goal[0] && curr.y == goal[1]) {\n                System.out.println(\"Goal reached. Cost: \" + curr.g);\n                return;\n            }\n            if (visited[curr.x][curr.y]) continue;\n            visited[curr.x][curr.y] = true;\n            int[][] directions = {{0,1},{1,0},{0,-1},{-1,0}};\n            for (int[] d : directions) {\n                int nx = curr.x + d[0], ny = curr.y + d[1];\n                if (nx >= 0 && ny >= 0 && nx < rows && ny < cols && grid[nx][ny] == 0 && !visited[nx][ny]) {\n                    int newG = curr.g + 1;\n                    int newH = heuristic(nx, ny, goal[0], goal[1]);\n                    pq.offer(new Node(nx, ny, newG, newH, curr));\n                }\n            }\n        }\n        System.out.println(\"No path found.\");\n    }\n\n    public static void main(String[] args) {\n        int[][] grid = {\n            {0, 0, 0, 0},\n            {1, 1, 0, 1},\n            {0, 0, 0, 0},\n            {0, 1, 1, 0}\n        };\n        int[] start = {0, 0}, goal = {3, 3};\n        aStar(grid, start, goal);\n    }\n}",
    "python": "import heapq\n\ndef heuristic(a, b):\n    return abs(a[0] - b[0]) + abs(a[1] - b[1])\n\ndef a_star(grid, start, goal):\n    rows, cols = len(grid), len(grid[0])\n    open_set = [(0 + heuristic(start, goal), 0, start, None)]\n    visited = set()\n    while open_set:\n        f, g, current, parent = heapq.heappop(open_set)\n        if current == goal:\n            print(f''Goal reached. Cost: {g}'')\n            return\n        if current in visited:\n            continue\n        visited.add(current)\n        for dx, dy in [(0,1),(1,0),(0,-1),(-1,0)]:\n            nx, ny = current[0] + dx, current[1] + dy\n            if 0 <= nx < rows and 0 <= ny < cols and grid[nx][ny] == 0:\n                neighbor = (nx, ny)\n                if neighbor not in visited:\n                    heapq.heappush(open_set, (g+1+heuristic(neighbor, goal), g+1, neighbor, current))\n    print('No path found.')\n\ngrid = [\n    [0, 0, 0, 0],\n    [1, 1, 0, 1],\n    [0, 0, 0, 0],\n    [0, 1, 1, 0]\n]\nstart = (0, 0)\ngoal = (3, 3)\na_star(grid, start, goal)",
    "cpp": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <cmath>\n#include <tuple>\nusing namespace std;\n\nstruct Node {\n    int x, y, g, h;\n    Node* parent;\n    Node(int x, int y, int g, int h, Node* p) : x(x), y(y), g(g), h(h), parent(p) {}\n    int f() const { return g + h; }\n};\n\nstruct Compare {\n    bool operator()(Node* a, Node* b) {\n        return a->f() > b->f();\n    }\n};\n\nint heuristic(int x1, int y1, int x2, int y2) {\n    return abs(x1 - x2) + abs(y1 - y2);\n}\n\nvoid aStar(vector<vector<int>>& grid, pair<int, int> start, pair<int, int> goal) {\n    int rows = grid.size(), cols = grid[0].size();\n    vector<vector<bool>> visited(rows, vector<bool>(cols, false));\n    priority_queue<Node*, vector<Node*>, Compare> pq;\n    pq.push(new Node(start.first, start.second, 0, heuristic(start.first, start.second, goal.first, goal.second), nullptr));\n    while (!pq.empty()) {\n        Node* curr = pq.top(); pq.pop();\n        if (curr->x == goal.first && curr->y == goal.second) {\n            cout << \"Goal reached. Cost: \" << curr->g << endl;\n            return;\n        }\n        if (visited[curr->x][curr->y]) continue;\n        visited[curr->x][curr->y] = true;\n        vector<pair<int, int>> directions = {{0,1},{1,0},{0,-1},{-1,0}};\n        for (auto& d : directions) {\n            int nx = curr->x + d.first, ny = curr->y + d.second;\n            if (nx >= 0 && ny >= 0 && nx < rows && ny < cols && grid[nx][ny] == 0 && !visited[nx][ny]) {\n                int newG = curr->g + 1;\n                int newH = heuristic(nx, ny, goal.first, goal.second);\n                pq.push(new Node(nx, ny, newG, newH, curr));\n            }\n        }\n    }\n    cout << \"No path found.\" << endl;\n}\n\nint main() {\n    vector<vector<int>> grid = {\n        {0, 0, 0, 0},\n        {1, 1, 0, 1},\n        {0, 0, 0, 0},\n        {0, 1, 1, 0}\n    };\n    aStar(grid, {0, 0}, {3, 3});\n    return 0;\n}",
    "mainImage": "https://res.cloudinary.com/daozctcil/image/upload/v1751442441/1a7260e2-d27f-4768-a6e2-b16dd5d73ab6.png",
    "slideshowImage": [],
    "category": [
      "Graph & Tree"
    ]
  },
  {
    "number": 44,
    "times_viewed": 0,
    "id":"naive_string",
    "name":"Naive String",
    "description":"Naive String Matching checks for the presence of a pattern in a text by comparing each substring of the text with the pattern one by one.\n\nExplaination:\nThis brute-force algorithm slides the pattern over the text one character at a time and compares it character-by-character. If all characters match, the index is reported as a match. If a mismatch is found, it shifts the pattern by one position and repeats. It's simple but inefficient for large inputs. Useful for small texts, or as a baseline before applying advanced algorithms like KMP or Rabin-Karp.\n\nTime Complexity:\n- O(n × m) where n = length of text, m = length of pattern\n\nSpace Complexity: O(1)",
    "java":"public class NaiveStringMatch {\n    public static void search(String text, String pattern) {\n        int n = text.length(), m = pattern.length();\n        for (int i = 0; i <= n - m; i++) {\n            int j;\n            for (j = 0; j < m; j++) {\n                if (text.charAt(i + j) != pattern.charAt(j)) break;\n            }\n            if (j == m) System.out.println(\"Pattern found at index \" + i);\n        }\n    }\n    public static void main(String[] args) {\n        search(\"ababcabcabababd\", \"ababd\");\n    }\n}",
    "python":"def naive_string_match(text, pattern):\n    n, m = len(text), len(pattern)\n    for i in range(n - m + 1):\n        match = True\n        for j in range(m):\n            if text[i + j] != pattern[j]:\n                match = False\n                break\n        if match:\n            print(f''Pattern found at index {i}'')\n\nnaive_string_match('ababcabcabababd', 'ababd')",
    "cpp":"#include <iostream>\n#include <string>\nusing namespace std;\n\nvoid naiveStringMatch(string text, string pattern) {\n    int n = text.length(), m = pattern.length();\n    for (int i = 0; i <= n - m; i++) {\n        int j;\n        for (j = 0; j < m; j++) {\n            if (text[i + j] != pattern[j]) break;\n        }\n        if (j == m) cout << \"Pattern found at index \" << i << endl;\n    }\n}\n\nint main() {\n    naiveStringMatch(\"ababcabcabababd\", \"ababd\");\n    return 0;\n}",
    "mainImage":"https://res.cloudinary.com/daozctcil/image/upload/v1751442522/c26c5124-9de4-454a-8ab3-b7f91cb72fa9.png",
    "slideshowImage":["https://res.cloudinary.com/daozctcil/image/upload/v1751442590/b1129295-2fd3-494e-a0bb-d5dcc37fe2ba.png"],
    "category": [
      "Searching"
    ]
  },
  {
    "number": 47,
    "times_viewed": 0,
    "id": "tower_of_hanoi",
    "name": "Tower of Hanoi",
    "description": "Tower of Hanoi is a classic recursive problem that involves moving a stack of disks from one rod to another, obeying specific rules.\n\nExplaination:\nThe goal is to move n disks from a source rod to a target rod using an auxiliary rod, following these rules: only one disk can be moved at a time, a larger disk cannot be placed on a smaller one, and only the top disk can be moved. The solution involves moving n-1 disks to the auxiliary rod, moving the nth (largest) disk to the target, and finally moving the n-1 disks from auxiliary to target. The minimum number of moves required is 2ⁿ - 1.\n\nTime Complexity:\n- O(2ⁿ)\n\nSpace Complexity: O(n) (due to recursion stack)",
    "java": "public class TowerOfHanoi {\n    public static void solve(int n, char source, char auxiliary, char target) {\n        if (n == 1) {\n            System.out.println(\"Move disk 1 from \" + source + \" to \" + target);\n            return;\n        }\n        solve(n - 1, source, target, auxiliary);\n        System.out.println(\"Move disk \" + n + \" from \" + source + \" to \" + target);\n        solve(n - 1, auxiliary, source, target);\n    }\n\n    public static void main(String[] args) {\n        int n = 3;\n        solve(n, 'A', 'B', 'C');\n    }\n}",
    "python": "def tower_of_hanoi(n, source, auxiliary, target):\n    if n == 1:\n        print(f''Move disk 1 from {source} to {target}'')\n        return\n    tower_of_hanoi(n-1, source, target, auxiliary)\n    print(f''Move disk {n} from {source} to {target}'')\n    tower_of_hanoi(n-1, auxiliary, source, target)\n\ntower_of_hanoi(3, 'A', 'B', 'C')",
    "cpp": "#include <iostream>\nusing namespace std;\n\nvoid towerOfHanoi(int n, char source, char auxiliary, char target) {\n    if (n == 1) {\n        cout << \"Move disk 1 from \" << source << \" to \" << target << endl;\n        return;\n    }\n    towerOfHanoi(n - 1, source, target, auxiliary);\n    cout << \"Move disk \" << n << \" from \" << source << \" to \" << target << endl;\n    towerOfHanoi(n - 1, auxiliary, source, target);\n}\n\nint main() {\n    int n = 3;\n    towerOfHanoi(n, 'A', 'B', 'C');\n    return 0;\n}",
    "mainImage": "https://res.cloudinary.com/daozctcil/image/upload/v1751442620/d163db22-48f2-48b9-8941-49987cc344aa.png",
    "slideshowImage": ["https://res.cloudinary.com/daozctcil/image/upload/v1751442680/99475fc9-e2e8-4882-9657-8d85a6e70dc6.png","https://res.cloudinary.com/daozctcil/image/upload/v1751442701/bdb55bc2-2732-4bf5-bd3c-59a05a9037cf.png","https://res.cloudinary.com/daozctcil/image/upload/v1751442732/667b7213-6dd1-40bd-b629-246b402df522.png","https://res.cloudinary.com/daozctcil/image/upload/v1751442770/426e3552-61cc-4cdb-b5f5-13f64dd07c08.png"],
    "category": [
      "Recursion & Backtracking"
    ]
  },
  {
    "number": 48,
    "times_viewed": 0,
    "id": "n_queens_problem",
    "name": "N-Queens Problem",
    "description": "The N-Queens problem is a classic backtracking problem where the goal is to place N queens on an N×N chessboard such that no two queens attack each other.\n\nExplaination:\nThe challenge is to place queens such that no two are in the same row, column, or diagonal. The solution uses backtracking: we try placing a queen in each column of a row, and if it's safe, we move to the next row. If we reach an invalid state, we backtrack. The safety check includes verifying that no queen is already placed in the same column or along the two diagonals. This algorithm explores all possible placements to find all valid configurations.\n\nTime Complexity:\n- O(N!) in the worst case\n\nSpace Complexity: O(N²) if storing board, or O(N) with position arrays",
    "java": "import java.util.*;\npublic class NQueens {\n    public static void solveNQueens(int n) {\n        char[][] board = new char[n][n];\n        for (char[] row : board) Arrays.fill(row, '.');\n        backtrack(0, board, n);\n    }\n\n    private static void backtrack(int row, char[][] board, int n) {\n        if (row == n) {\n            printBoard(board);\n            return;\n        }\n        for (int col = 0; col < n; col++) {\n            if (isSafe(board, row, col, n)) {\n                board[row][col] = 'Q';\n                backtrack(row + 1, board, n);\n                board[row][col] = '.';\n            }\n        }\n    }\n\n    private static boolean isSafe(char[][] board, int row, int col, int n) {\n        for (int i = 0; i < row; i++) if (board[i][col] == 'Q') return false;\n        for (int i = row - 1, j = col - 1; i >= 0 && j >= 0; i--, j--) if (board[i][j] == 'Q') return false;\n        for (int i = row - 1, j = col + 1; i >= 0 && j < n; i--, j++) if (board[i][j] == 'Q') return false;\n        return true;\n    }\n\n    private static void printBoard(char[][] board) {\n        for (char[] row : board) System.out.println(Arrays.toString(row));\n        System.out.println();\n    }\n\n    public static void main(String[] args) {\n        solveNQueens(4);\n    }\n}",
    "python": "def solve_n_queens(n):\n    board = [['.' for _ in range(n)] for _ in range(n)]\n    def is_safe(row, col):\n        for i in range(row):\n            if board[i][col] == 'Q': return False\n            if col - (row - i) >= 0 and board[i][col - (row - i)] == 'Q': return False\n            if col + (row - i) < n and board[i][col + (row - i)] == 'Q': return False\n        return True\n\n    def backtrack(row):\n        if row == n:\n            for r in board:\n                print(''.join(r))\n            print()\n            return\n        for col in range(n):\n            if is_safe(row, col):\n                board[row][col] = 'Q'\n                backtrack(row + 1)\n                board[row][col] = '.'\n\n    backtrack(0)\n\nsolve_n_queens(4)",
    "cpp": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nvoid printBoard(const vector<string>& board) {\n    for (const string& row : board) cout << row << endl;\n    cout << endl;\n}\n\nbool isSafe(const vector<string>& board, int row, int col, int n) {\n    for (int i = 0; i < row; i++) if (board[i][col] == 'Q') return false;\n    for (int i = row - 1, j = col - 1; i >= 0 && j >= 0; i--, j--) if (board[i][j] == 'Q') return false;\n    for (int i = row - 1, j = col + 1; i >= 0 && j < n; i--, j++) if (board[i][j] == 'Q') return false;\n    return true;\n}\n\nvoid solve(int row, vector<string>& board, int n) {\n    if (row == n) {\n        printBoard(board);\n        return;\n    }\n    for (int col = 0; col < n; col++) {\n        if (isSafe(board, row, col, n)) {\n            board[row][col] = 'Q';\n            solve(row + 1, board, n);\n            board[row][col] = '.';\n        }\n    }\n}\n\nint main() {\n    int n = 4;\n    vector<string> board(n, string(n, '.'));\n    solve(0, board, n);\n    return 0;\n}",
    "mainImage": "https://res.cloudinary.com/daozctcil/image/upload/v1751442889/983c6cb9-d819-4fb8-aac5-59b6a1774f7e.png",
    "slideshowImage": ["https://res.cloudinary.com/daozctcil/image/upload/v1751442917/bd6f5444-0f47-4ae1-ad11-0c57e746a381.png","https://res.cloudinary.com/daozctcil/image/upload/v1751442914/9866c00d-dc89-4882-948f-2e03f5c98d8d.png"],
    "category": [
      "Recursion & Backtracking"
    ]
  },
  {
    "number": 49,
    "times_viewed": 0,
    "id": "sudoku_solver",
    "name": "Sudoku Solver",
    "description": "The Sudoku Solver is a backtracking algorithm that fills an incomplete 9×9 Sudoku board such that each row, column, and 3×3 box contains digits 1–9 exactly once.\n\nExplaination:\nThe solver iterates through each cell and attempts to place digits from 1 to 9. For each placement, it checks if the digit is valid in the current row, column, and 3×3 box. If valid, it moves to the next cell recursively. If stuck, it backtracks and tries a different number. The process continues until the board is filled correctly. This approach is efficient for most Sudoku puzzles and guarantees a solution if one exists.\n\nTime Complexity:\n- O(9^(n*n)) in the worst case\n\nSpace Complexity: O(1) extra (board is modified in-place)",
    "java": "public class SudokuSolver {\n    public static boolean solve(char[][] board) {\n        for (int row = 0; row < 9; row++) {\n            for (int col = 0; col < 9; col++) {\n                if (board[row][col] == '.') {\n                    for (char c = '1'; c <= '9'; c++) {\n                        if (isValid(board, row, col, c)) {\n                            board[row][col] = c;\n                            if (solve(board)) return true;\n                            board[row][col] = '.';\n                        }\n                    }\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n\n    private static boolean isValid(char[][] board, int row, int col, char c) {\n        for (int i = 0; i < 9; i++) {\n            if (board[row][i] == c || board[i][col] == c || board[3*(row/3)+i/3][3*(col/3)+i%3] == c)\n                return false;\n        }\n        return true;\n    }\n\n    public static void main(String[] args) {\n        char[][] board = {\n            {'5','3','.','.','7','.','.','.','.'},\n            {'6','.','.','1','9','5','.','.','.'},\n            {'.','9','8','.','.','.','.','6','.'},\n            {'8','.','.','.','6','.','.','.','3'},\n            {'4','.','.','8','.','3','.','.','1'},\n            {'7','.','.','.','2','.','.','.','6'},\n            {'.','6','.','.','.','.','2','8','.'},\n            {'.','.','.','4','1','9','.','.','5'},\n            {'.','.','.','.','8','.','.','7','9'}\n        };\n        solve(board);\n        for (char[] row : board) System.out.println(java.util.Arrays.toString(row));\n    }\n}",
    "python": "def is_valid(board, row, col, num):\n    for i in range(9):\n        if board[row][i] == num or board[i][col] == num:\n            return False\n        if board[3*(row//3)+i//3][3*(col//3)+i%3] == num:\n            return False\n    return True\n\ndef solve(board):\n    for row in range(9):\n        for col in range(9):\n            if board[row][col] == '.':\n                for num in '123456789':\n                    if is_valid(board, row, col, num):\n                        board[row][col] = num\n                        if solve(board):\n                            return True\n                        board[row][col] = '.'\n                return False\n    return True\n\nboard = [\n    ['5','3','.','.','7','.','.','.','.'],\n    ['6','.','.','1','9','5','.','.','.'],\n    ['.','9','8','.','.','.','.','6','.'],\n    ['8','.','.','.','6','.','.','.','3'],\n    ['4','.','.','8','.','3','.','.','1'],\n    ['7','.','.','.','2','.','.','.','6'],\n    ['.','6','.','.','.','.','2','8','.'],\n    ['.','.','.','4','1','9','.','.','5'],\n    ['.','.','.','.','8','.','.','7','9']\n]\nsolve(board)\nfor row in board:\n    print(' '.join(row))",
    "cpp": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nbool isValid(vector<vector<char>>& board, int row, int col, char c) {\n    for (int i = 0; i < 9; i++) {\n        if (board[row][i] == c || board[i][col] == c) return false;\n        if (board[3*(row/3)+i/3][3*(col/3)+i%3] == c) return false;\n    }\n    return true;\n}\n\nbool solve(vector<vector<char>>& board) {\n    for (int row = 0; row < 9; row++) {\n        for (int col = 0; col < 9; col++) {\n            if (board[row][col] == '.') {\n                for (char c = '1'; c <= '9'; c++) {\n                    if (isValid(board, row, col, c)) {\n                        board[row][col] = c;\n                        if (solve(board)) return true;\n                        board[row][col] = '.';\n                    }\n                }\n                return false;\n            }\n        }\n    }\n    return true;\n}\n\nint main() {\n    vector<vector<char>> board = {\n        {'5','3','.','.','7','.','.','.','.'},\n        {'6','.','.','1','9','5','.','.','.'},\n        {'.','9','8','.','.','.','.','6','.'},\n        {'8','.','.','.','6','.','.','.','3'},\n        {'4','.','.','8','.','3','.','.','1'},\n        {'7','.','.','.','2','.','.','.','6'},\n        {'.','6','.','.','.','.','2','8','.'},\n        {'.','.','.','4','1','9','.','.','5'},\n        {'.','.','.','.','8','.','.','7','9'}\n    };\n    solve(board);\n    for (auto& row : board) {\n        for (char c : row) cout << c << ' ';\n        cout << endl;\n    }\n    return 0;\n}",
    "mainImage": "",
    "slideshowImage": [],
    "category": [
      "Recursion & Backtracking"
    ]
  },
  {
    "number": 50,
    "times_viewed": 0,
    "id": "rat_in_a_maze",
    "name": "Rat in a Maze",
    "description": "Rat in a Maze is a backtracking algorithm where the goal is to find all paths from the top-left to the bottom-right of a grid, moving only through allowed cells.\n\nExplaination:\nThe maze is represented by a 2D grid where 1 indicates open paths and 0 indicates walls. The rat starts at the top-left cell and must reach the bottom-right cell by moving only in allowed directions (typically down, right, up, left) without revisiting any cell. The algorithm explores all possible paths using recursion and backtracking, storing successful ones. It's commonly used to teach recursion and explore combinatorial paths.\n\nTime Complexity:\n- O(4^(n×n)) in the worst case\n\nSpace Complexity: O(n×n) for the visited matrix and recursion stack",
    "java": "import java.util.*;\npublic class RatInMaze {\n    public static void findPaths(int[][] maze, int n) {\n        boolean[][] visited = new boolean[n][n];\n        List<String> paths = new ArrayList<>();\n        backtrack(0, 0, maze, visited, \"\", paths, n);\n        System.out.println(\"Paths: \" + paths);\n    }\n\n    static void backtrack(int x, int y, int[][] maze, boolean[][] visited, String path, List<String> paths, int n) {\n        if (x < 0 || y < 0 || x >= n || y >= n || maze[x][y] == 0 || visited[x][y]) return;\n        if (x == n - 1 && y == n - 1) {\n            paths.add(path);\n            return;\n        }\n        visited[x][y] = true;\n        backtrack(x + 1, y, maze, visited, path + \"D\", paths, n);\n        backtrack(x, y + 1, maze, visited, path + \"R\", paths, n);\n        backtrack(x - 1, y, maze, visited, path + \"U\", paths, n);\n        backtrack(x, y - 1, maze, visited, path + \"L\", paths, n);\n        visited[x][y] = false;\n    }\n\n    public static void main(String[] args) {\n        int[][] maze = {\n            {1, 0, 0, 0},\n            {1, 1, 0, 1},\n            {0, 1, 0, 0},\n            {1, 1, 1, 1}\n        };\n        findPaths(maze, 4);\n    }\n}",
    "python": "def rat_in_maze(maze):\n    n = len(maze)\n    result = []\n    visited = [[False]*n for _ in range(n)]\n\n    def backtrack(x, y, path):\n        if x < 0 or y < 0 or x >= n or y >= n or maze[x][y] == 0 or visited[x][y]:\n            return\n        if x == n - 1 and y == n - 1:\n            result.append(path)\n            return\n        visited[x][y] = True\n        backtrack(x+1, y, path + 'D')\n        backtrack(x, y+1, path + 'R')\n        backtrack(x-1, y, path + 'U')\n        backtrack(x, y-1, path + 'L')\n        visited[x][y] = False\n\n    backtrack(0, 0, '')\n    print(f''Paths: {result}'')\n\nmaze = [\n    [1, 0, 0, 0],\n    [1, 1, 0, 1],\n    [0, 1, 0, 0],\n    [1, 1, 1, 1]\n]\nrat_in_maze(maze)",
    "cpp": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nvoid backtrack(int x, int y, vector<vector<int>>& maze, vector<vector<bool>>& visited, string path, vector<string>& paths, int n) {\n    if (x < 0 || y < 0 || x >= n || y >= n || maze[x][y] == 0 || visited[x][y]) return;\n    if (x == n - 1 && y == n - 1) {\n        paths.push_back(path);\n        return;\n    }\n    visited[x][y] = true;\n    backtrack(x + 1, y, maze, visited, path + 'D', paths, n);\n    backtrack(x, y + 1, maze, visited, path + 'R', paths, n);\n    backtrack(x - 1, y, maze, visited, path + 'U', paths, n);\n    backtrack(x, y - 1, maze, visited, path + 'L', paths, n);\n    visited[x][y] = false;\n}\n\nvoid ratInMaze(vector<vector<int>>& maze, int n) {\n    vector<vector<bool>> visited(n, vector<bool>(n, false));\n    vector<string> paths;\n    backtrack(0, 0, maze, visited, \"\", paths, n);\n    cout << \"Paths: \";\n    for (string& path : paths) cout << path << \" \";\n    cout << endl;\n}\n\nint main() {\n    vector<vector<int>> maze = {\n        {1, 0, 0, 0},\n        {1, 1, 0, 1},\n        {0, 1, 0, 0},\n        {1, 1, 1, 1}\n    };\n    ratInMaze(maze, 4);\n    return 0;\n}",
    "mainImage": "",
    "slideshowImage": [],
    "category": [
      "Recursion & Backtracking"
    ]
  },
  {
    "number": 51,
    "times_viewed": 0,
    "id": "subset_sum",
    "name": "Subset Sum",
    "description": "The Subset Sum problem determines whether there exists a subset of a given set of integers that adds up to a specific target sum.\n\nExplaination:\nThis problem can be solved using backtracking or dynamic programming. In backtracking, we explore both including and excluding each element recursively. In the DP approach, we use a 2D boolean table where dp[i][j] is true if a sum j can be formed using the first i elements. If the final cell dp[n][sum] is true, a subset with the target sum exists. It's widely used in optimization and decision-making problems.\n\nTime Complexity:\n- Backtracking: O(2ⁿ)\n- Dynamic Programming: O(n × sum)\n\nSpace Complexity: O(n × sum) for DP",
    "java": "public class SubsetSum {\n    public static boolean isSubsetSum(int[] arr, int sum) {\n        int n = arr.length;\n        boolean[][] dp = new boolean[n + 1][sum + 1];\n        for (int i = 0; i <= n; i++) dp[i][0] = true;\n        for (int i = 1; i <= n; i++) {\n            for (int j = 1; j <= sum; j++) {\n                if (arr[i - 1] > j)\n                    dp[i][j] = dp[i - 1][j];\n                else\n                    dp[i][j] = dp[i - 1][j] || dp[i - 1][j - arr[i - 1]];\n            }\n        }\n        return dp[n][sum];\n    }\n\n    public static void main(String[] args) {\n        int[] arr = {3, 34, 4, 12, 5, 2};\n        int sum = 9;\n        System.out.println(\"Subset with sum \" + sum + \" exists: \" + isSubsetSum(arr, sum));\n    }\n}",
    "python": "def is_subset_sum(arr, target):\n    n = len(arr)\n    dp = [[False]*(target+1) for _ in range(n+1)]\n    for i in range(n+1):\n        dp[i][0] = True\n    for i in range(1, n+1):\n        for j in range(1, target+1):\n            if arr[i-1] > j:\n                dp[i][j] = dp[i-1][j]\n            else:\n                dp[i][j] = dp[i-1][j] or dp[i-1][j-arr[i-1]]\n    return dp[n][target]\n\narr = [3, 34, 4, 12, 5, 2]\ntarget = 9\nprint(f''Subset with sum {target} exists: {is_subset_sum(arr, target)}'')",
    "cpp": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nbool isSubsetSum(vector<int>& arr, int sum) {\n    int n = arr.size();\n    vector<vector<bool>> dp(n + 1, vector<bool>(sum + 1, false));\n    for (int i = 0; i <= n; i++) dp[i][0] = true;\n    for (int i = 1; i <= n; i++) {\n        for (int j = 1; j <= sum; j++) {\n            if (arr[i - 1] > j)\n                dp[i][j] = dp[i - 1][j];\n            else\n                dp[i][j] = dp[i - 1][j] || dp[i - 1][j - arr[i - 1]];\n        }\n    }\n    return dp[n][sum];\n}\n\nint main() {\n    vector<int> arr = {3, 34, 4, 12, 5, 2};\n    int sum = 9;\n    cout << \"Subset with sum \" << sum << \" exists: \" << (isSubsetSum(arr, sum) ? \"true\" : \"false\") << endl;\n    return 0;\n}",
    "mainImage": "",
    "slideshowImage": [],
    "category": [
      "Recursion & Backtracking"
    ]
  },
  {
    "number": 52,
    "times_viewed": 0,
    "id": "permutations",
    "name": "Permutations",
    "description": "The Permutations problem generates all possible arrangements of a given list of distinct elements using backtracking.\n\nExplaination:\nPermutations involve rearranging all elements of a list in every possible order. The backtracking approach explores all configurations by swapping the current element with each of the remaining elements, then recursively permuting the rest of the list. After recursion, we backtrack by swapping the elements back. This algorithm ensures that all permutations are covered without repetition.\n\nTime Complexity:\n- O(n × n!)\n\nSpace Complexity: O(n) for recursion stack and current permutation",
    "java": "import java.util.*;\npublic class Permutations {\n    public static void permute(int[] arr, int start, List<List<Integer>> result) {\n        if (start == arr.length) {\n            List<Integer> temp = new ArrayList<>();\n            for (int num : arr) temp.add(num);\n            result.add(temp);\n            return;\n        }\n        for (int i = start; i < arr.length; i++) {\n            swap(arr, i, start);\n            permute(arr, start + 1, result);\n            swap(arr, i, start);\n        }\n    }\n\n    private static void swap(int[] arr, int i, int j) {\n        int temp = arr[i];\n        arr[i] = arr[j];\n        arr[j] = temp;\n    }\n\n    public static void main(String[] args) {\n        int[] arr = {1, 2, 3};\n        List<List<Integer>> result = new ArrayList<>();\n        permute(arr, 0, result);\n        System.out.println(\"Permutations: \" + result);\n    }\n}",    "python": "def permute(nums):\n    result = []\n    def backtrack(start):\n        if start == len(nums):\n            result.append(nums[:])\n            return\n        for i in range(start, len(nums)):\n            nums[start], nums[i] = nums[i], nums[start]\n            backtrack(start + 1)\n            nums[start], nums[i] = nums[i], nums[start]\n    backtrack(0)\n    print(f''Permutations: {result}'')\n\npermute([1, 2, 3])",
    "cpp": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nvoid permute(vector<int>& nums, int start, vector<vector<int>>& result) {\n    if (start == nums.size()) {\n        result.push_back(nums);\n        return;\n    }\n    for (int i = start; i < nums.size(); i++) {\n        swap(nums[start], nums[i]);\n        permute(nums, start + 1, result);\n        swap(nums[start], nums[i]);\n    }\n}\n\nint main() {\n    vector<int> nums = {1, 2, 3};\n    vector<vector<int>> result;\n    permute(nums, 0, result);\n    cout << \"Permutations:\\n\";\n    for (auto& perm : result) {\n        for (int x : perm) cout << x << ' ';\n        cout << endl;\n    }\n    return 0;\n}",
    "mainImage": "",
    "slideshowImage": [],
    "category": [
      "Recursion & Backtracking"
    ]
  },
  {
    "number": 54,
    "times_viewed": 0,
    "id": "word_search",
    "name": "Word Search",
    "description": "Word Search is a backtracking problem that checks whether a given word can be formed by sequentially adjacent letters in a 2D board, without reusing the same cell.\n\nExplaination:\nThe algorithm starts a DFS from every cell that matches the first character of the word. From each cell, it recursively explores its 4 neighbors (up, down, left, right) while marking the current cell as visited. If the full word is matched, it returns true. Backtracking ensures cells are unmarked once a path is abandoned. This approach is useful in puzzles and games like Boggle or crossword solvers.\n\nTime Complexity:\n- O(m × n × 4^L), where m×n is board size, and L is word length\n\nSpace Complexity: O(L) for recursion stack",
    "java": "public class WordSearch {\n    public static boolean exist(char[][] board, String word) {\n        int rows = board.length, cols = board[0].length;\n        for (int i = 0; i < rows; i++) {\n            for (int j = 0; j < cols; j++) {\n                if (dfs(board, word, 0, i, j)) return true;\n            }\n        }\n        return false;\n    }\n\n    private static boolean dfs(char[][] board, String word, int index, int x, int y) {\n        if (index == word.length()) return true;\n        if (x < 0 || y < 0 || x >= board.length || y >= board[0].length || board[x][y] != word.charAt(index)) return false;\n        char temp = board[x][y];\n        board[x][y] = '#';\n        boolean found = dfs(board, word, index + 1, x + 1, y) ||\n                        dfs(board, word, index + 1, x - 1, y) ||\n                        dfs(board, word, index + 1, x, y + 1) ||\n                        dfs(board, word, index + 1, x, y - 1);\n        board[x][y] = temp;\n        return found;\n    }\n\n    public static void main(String[] args) {\n        char[][] board = {\n            {'A','B','C','E'},\n            {'S','F','C','S'},\n            {'A','D','E','E'}\n        };\n        String word = \"ABCCED\";\n        System.out.println(\"Word found: \" + exist(board, word));\n    }\n}",
    "python": "def exist(board, word):\n    rows, cols = len(board), len(board[0])\n    def dfs(r, c, i):\n        if i == len(word): return True\n        if r < 0 or c < 0 or r >= rows or c >= cols or board[r][c] != word[i]: return False\n        temp = board[r][c]\n        board[r][c] = '#'\n        found = dfs(r+1, c, i+1) or dfs(r-1, c, i+1) or dfs(r, c+1, i+1) or dfs(r, c-1, i+1)\n        board[r][c] = temp\n        return found\n    for i in range(rows):\n        for j in range(cols):\n            if dfs(i, j, 0):\n                return True\n    return False\n\nboard = [\n    ['A','B','C','E'],\n    ['S','F','C','S'],\n    ['A','D','E','E']\n]\nword = \"ABCCED\"\nprint(f''Word exists: {exist(board, word)}'')",
    "cpp": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nbool dfs(vector<vector<char>>& board, string& word, int r, int c, int idx) {\n    if (idx == word.length()) return true;\n    if (r < 0 || c < 0 || r >= board.size() || c >= board[0].size() || board[r][c] != word[idx]) return false;\n    char temp = board[r][c];\n    board[r][c] = '#';\n    bool found = dfs(board, word, r+1, c, idx+1) || dfs(board, word, r-1, c, idx+1) || dfs(board, word, r, c+1, idx+1) || dfs(board, word, r, c-1, idx+1);\n    board[r][c] = temp;\n    return found;\n}\n\nbool exist(vector<vector<char>>& board, string word) {\n    for (int i = 0; i < board.size(); i++) {\n        for (int j = 0; j < board[0].size(); j++) {\n            if (dfs(board, word, i, j, 0)) return true;\n        }\n    }\n    return false;\n}\n\nint main() {\n    vector<vector<char>> board = {\n        {'A','B','C','E'},\n        {'S','F','C','S'},\n        {'A','D','E','E'}\n    };\n    string word = \"ABCCED\";\n    cout << \"Word exists: \" << (exist(board, word) ? \"true\" : \"false\") << endl;\n    return 0;\n}",
    "mainImage": "",
    "slideshowImage": [],
    "category": [
      "Recursion & Backtracking"
    ]
  },
  {
    "number": 55,
    "times_viewed": 0,
    "id": "combination_sum",
    "name": "Combination Sum",
    "description": "The Combination Sum problem finds all unique combinations of numbers that sum to a target value, allowing repeated use of elements.\n\nExplaination:\nGiven an array of distinct integers and a target, the goal is to find all combinations where the chosen numbers sum to the target. We use backtracking: at each step, we either include the current number and recurse with a reduced target (allowing reuse), or skip to the next number. If the target becomes zero, we add the current path to the result. This problem explores branching with inclusion/exclusion logic and pruning when the sum exceeds the target.\n\nTime Complexity:\n- O(2^target) in the worst case\n\nSpace Complexity: O(target) for the recursion path",
    "java": "import java.util.*;\npublic class CombinationSum {\n    public static List<List<Integer>> combinationSum(int[] candidates, int target) {\n        List<List<Integer>> result = new ArrayList<>();\n        backtrack(candidates, target, 0, new ArrayList<>(), result);\n        return result;\n    }\n\n    private static void backtrack(int[] nums, int target, int index, List<Integer> current, List<List<Integer>> result) {\n        if (target == 0) {\n            result.add(new ArrayList<>(current));\n            return;\n        }\n        if (target < 0 || index == nums.length) return;\n        current.add(nums[index]);\n        backtrack(nums, target - nums[index], index, current, result);\n        current.remove(current.size() - 1);\n        backtrack(nums, target, index + 1, current, result);\n    }\n\n    public static void main(String[] args) {\n        int[] candidates = {2, 3, 6, 7};\n        int target = 7;\n        List<List<Integer>> result = combinationSum(candidates, target);\n        System.out.println(\"Combinations: \" + result);\n    }\n}",
    "python": "def combination_sum(candidates, target):\n    result = []\n    def backtrack(start, path, total):\n        if total == target:\n            result.append(path[:])\n            return\n        if total > target:\n            return\n        for i in range(start, len(candidates)):\n            path.append(candidates[i])\n            backtrack(i, path, total + candidates[i])\n            path.pop()\n    backtrack(0, [], 0)\n    print(f''Combinations: {result}'')\n\ncombination_sum([2, 3, 6, 7], 7)",
    "cpp": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nvoid backtrack(vector<int>& candidates, int target, int index, vector<int>& path, vector<vector<int>>& result) {\n    if (target == 0) {\n        result.push_back(path);\n        return;\n    }\n    if (target < 0 || index == candidates.size()) return;\n    path.push_back(candidates[index]);\n    backtrack(candidates, target - candidates[index], index, path, result);\n    path.pop_back();\n    backtrack(candidates, target, index + 1, path, result);\n}\n\nvector<vector<int>> combinationSum(vector<int>& candidates, int target) {\n    vector<vector<int>> result;\n    vector<int> path;\n    backtrack(candidates, target, 0, path, result);\n    return result;\n}\n\nint main() {\n    vector<int> candidates = {2, 3, 6, 7};\n    int target = 7;\n    vector<vector<int>> result = combinationSum(candidates, target);\n    cout << \"Combinations:\\n\";\n    for (auto& comb : result) {\n        for (int num : comb) cout << num << ' ';\n        cout << endl;\n    }\n    return 0;\n}",
    "mainImage": "",
    "slideshowImage": [],
    "category": [
      "Recursion & Backtracking"
    ]
  },
  {
    "number": 56,
    "times_viewed": 0,
    "id": "palindrome_partitioning",
    "name": "Palindrome Partitioning",
    "description": "The Palindrome Partitioning problem involves splitting a string into all possible lists of substrings such that each substring is a palindrome.\n\nExplaination:\nWe use backtracking to explore all ways to partition the string. Starting from index 0, we iterate through the string, and at each step, we check if the substring from start to current index is a palindrome. If yes, we include it in the current path and recursively check the rest of the string. Once we reach the end, the path is added to the result. This approach explores all valid partitions where each part is a palindrome.\n\nTime Complexity:\n- O(2ⁿ × n) for all partitions and substring checks\n\nSpace Complexity: O(n) recursion stack + O(2ⁿ) result size",
    "java": "import java.util.*;\npublic class PalindromePartitioning {\n    public static List<List<String>> partition(String s) {\n        List<List<String>> result = new ArrayList<>();\n        backtrack(s, 0, new ArrayList<>(), result);\n        return result;\n    }\n\n    private static void backtrack(String s, int start, List<String> current, List<List<String>> result) {\n        if (start == s.length()) {\n            result.add(new ArrayList<>(current));\n            return;\n        }\n        for (int end = start + 1; end <= s.length(); end++) {\n            String substr = s.substring(start, end);\n            if (isPalindrome(substr)) {\n                current.add(substr);\n                backtrack(s, end, current, result);\n                current.remove(current.size() - 1);\n            }\n        }\n    }\n\n    private static boolean isPalindrome(String str) {\n        int l = 0, r = str.length() - 1;\n        while (l < r) {\n            if (str.charAt(l++) != str.charAt(r--)) return false;\n        }\n        return true;\n    }\n\n    public static void main(String[] args) {\n        String s = \"aab\";\n        List<List<String>> result = partition(s);\n        System.out.println(\"Partitions: \" + result);\n    }\n}",
    "python": "def partition(s):\n    result = []\n    def backtrack(start, path):\n        if start == len(s):\n            result.append(path[:])\n            return\n        for end in range(start + 1, len(s) + 1):\n            substr = s[start:end]\n            if substr == substr[::-1]:\n                path.append(substr)\n                backtrack(end, path)\n                path.pop()\n    backtrack(0, [])\n    print(f''Partitions: {result}'')\n\npartition('aab')",
    "cpp": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nbool isPalindrome(const string& s, int l, int r) {\n    while (l < r) {\n        if (s[l++] != s[r--]) return false;\n    }\n    return true;\n}\n\nvoid backtrack(const string& s, int start, vector<string>& path, vector<vector<string>>& result) {\n    if (start == s.size()) {\n        result.push_back(path);\n        return;\n    }\n    for (int end = start; end < s.size(); ++end) {\n        if (isPalindrome(s, start, end)) {\n            path.push_back(s.substr(start, end - start + 1));\n            backtrack(s, end + 1, path, result);\n            path.pop_back();\n        }\n    }\n}\n\nvector<vector<string>> partition(string s) {\n    vector<vector<string>> result;\n    vector<string> path;\n    backtrack(s, 0, path, result);\n    return result;\n}\n\nint main() {\n    string s = \"aab\";\n    vector<vector<string>> result = partition(s);\n    cout << \"Partitions:\\n\";\n    for (auto& group : result) {\n        for (auto& word : group) cout << word << ' ';\n        cout << endl;\n    }\n    return 0;\n}",
    "mainImage": "",
    "slideshowImage": [],
    "category": [
      "Recursion & Backtracking"
    ]
  },
  {
    "number": 57,
    "times_viewed": 0,
    "id": "binary_tree_paths",
    "name": "Binary Tree Paths",
    "description": "The Binary Tree Paths problem finds all root-to-leaf paths in a binary tree and returns them as strings.\n\nExplaination:\nWe perform a depth-first traversal of the tree while building the path string from the root to the current node. When we reach a leaf node (both children are null), we add the constructed path to the result list. We backtrack while returning from the recursion, preserving path integrity. This is commonly used for exploring paths in trees or visualizing decision routes.\n\nTime Complexity:\n- O(n × h), where n is number of nodes and h is the average path length\n\nSpace Complexity: O(h) for recursion stack",
    "java": "import java.util.*;\nclass TreeNode {\n    int val;\n    TreeNode left, right;\n    TreeNode(int x) { val = x; }\n}\n\npublic class BinaryTreePaths {\n    public static List<String> binaryTreePaths(TreeNode root) {\n        List<String> result = new ArrayList<>();\n        if (root != null) dfs(root, \"\", result);\n        return result;\n    }\n\n    private static void dfs(TreeNode node, String path, List<String> result) {\n        if (node.left == null && node.right == null) {\n            result.add(path + node.val);\n            return;\n        }\n        if (node.left != null) dfs(node.left, path + node.val + \"->\", result);\n        if (node.right != null) dfs(node.right, path + node.val + \"->\", result);\n    }\n\n    public static void main(String[] args) {\n        TreeNode root = new TreeNode(1);\n        root.left = new TreeNode(2);\n        root.right = new TreeNode(3);\n        root.left.right = new TreeNode(5);\n        List<String> paths = binaryTreePaths(root);\n        System.out.println(\"Paths: \" + paths);\n    }\n}",
    "python": "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef binary_tree_paths(root):\n    result = []\n    def dfs(node, path):\n        if not node:\n            return\n        if not node.left and not node.right:\n            result.append(path + str(node.val))\n        else:\n            dfs(node.left, path + str(node.val) + '->')\n            dfs(node.right, path + str(node.val) + '->')\n    dfs(root, '')\n    print(f''Paths: {result}'')\n\nroot = TreeNode(1)\nroot.left = TreeNode(2)\nroot.right = TreeNode(3)\nroot.left.right = TreeNode(5)\nbinary_tree_paths(root)",
    "cpp": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nstruct TreeNode {\n    int val;\n    TreeNode* left;\n    TreeNode* right;\n    TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n};\n\nvoid dfs(TreeNode* node, string path, vector<string>& result) {\n    if (!node) return;\n    if (!node->left && !node->right) {\n        result.push_back(path + to_string(node->val));\n        return;\n    }\n    if (node->left) dfs(node->left, path + to_string(node->val) + \"->\", result);\n    if (node->right) dfs(node->right, path + to_string(node->val) + \"->\", result);\n}\n\nvector<string> binaryTreePaths(TreeNode* root) {\n    vector<string> result;\n    if (root) dfs(root, \"\", result);\n    return result;\n}\n\nint main() {\n    TreeNode* root = new TreeNode(1);\n    root->left = new TreeNode(2);\n    root->right = new TreeNode(3);\n    root->left->right = new TreeNode(5);\n    vector<string> paths = binaryTreePaths(root);\n    cout << \"Paths: \";\n    for (string& p : paths) cout << p << \" \";\n    cout << endl;\n    return 0;\n}",
    "mainImage": "",
    "slideshowImage": [],
    "category": [
      "Recursion & Backtracking"
    ]
  },
  {
    "number": 58,
    "times_viewed": 0,
    "id": "travelling_salesman",
    "name": "Travelling Salesman",
    "description": "The Travelling Salesman Problem (TSP) is an optimization problem where the goal is to find the shortest possible route that visits each city exactly once and returns to the origin.\n\nExplaination:\nTSP is an NP-hard problem usually solved using brute force (O(n!)), dynamic programming (Held-Karp, O(n²·2ⁿ)), or approximation for large inputs. The DP approach uses a bitmask to represent visited cities and memoization to avoid recalculating subproblems. At each step, we recursively visit unvisited cities and compute the minimum cost. This solution guarantees the shortest path but is only feasible for small n (typically n ≤ 20).\n\nTime Complexity:\n- O(n² × 2ⁿ) with DP\n\nSpace Complexity: O(n × 2ⁿ) for memoization",
    "java": "import java.util.*;\npublic class TSP {\n    static int tsp(int[][] dist) {\n        int n = dist.length;\n        int[][] dp = new int[1 << n][n];\n        for (int[] row : dp) Arrays.fill(row, Integer.MAX_VALUE / 2);\n        dp[1][0] = 0;\n        for (int mask = 1; mask < (1 << n); mask++) {\n            for (int u = 0; u < n; u++) {\n                if ((mask & (1 << u)) > 0) {\n                    for (int v = 0; v < n; v++) {\n                        if ((mask & (1 << v)) == 0) {\n                            int next = mask | (1 << v);\n                            dp[next][v] = Math.min(dp[next][v], dp[mask][u] + dist[u][v]);\n                        }\n                    }\n                }\n            }\n        }\n        int res = Integer.MAX_VALUE;\n        for (int i = 1; i < n; i++) res = Math.min(res, dp[(1 << n) - 1][i] + dist[i][0]);\n        return res;\n    }\n\n    public static void main(String[] args) {\n        int[][] dist = {\n            {0, 10, 15, 20},\n            {10, 0, 35, 25},\n            {15, 35, 0, 30},\n            {20, 25, 30, 0}\n        };\n        System.out.println(\"Minimum tour cost: \" + tsp(dist));\n    }\n}",
    "python": "def tsp(dist):\n    n = len(dist)\n    dp = [[float('inf')] * n for _ in range(1 << n)]\n    dp[1][0] = 0\n    for mask in range(1 << n):\n        for u in range(n):\n            if mask & (1 << u):\n                for v in range(n):\n                    if not mask & (1 << v):\n                        dp[mask | (1 << v)][v] = min(dp[mask | (1 << v)][v], dp[mask][u] + dist[u][v])\n    return min(dp[(1 << n) - 1][i] + dist[i][0] for i in range(1, n))\n\ndist = [\n    [0, 10, 15, 20],\n    [10, 0, 35, 25],\n    [15, 35, 0, 30],\n    [20, 25, 30, 0]\n]\nprint(f''Minimum tour cost: {tsp(dist)}'')",
    "cpp": "#include <iostream>\n#include <vector>\n#include <climits>\nusing namespace std;\n\nint tsp(vector<vector<int>>& dist) {\n    int n = dist.size();\n    vector<vector<int>> dp(1 << n, vector<int>(n, INT_MAX / 2));\n    dp[1][0] = 0;\n    for (int mask = 1; mask < (1 << n); ++mask) {\n        for (int u = 0; u < n; ++u) {\n            if (mask & (1 << u)) {\n                for (int v = 0; v < n; ++v) {\n                    if (!(mask & (1 << v))) {\n                        int next = mask | (1 << v);\n                        dp[next][v] = min(dp[next][v], dp[mask][u] + dist[u][v]);\n                    }\n                }\n            }\n        }\n    }\n    int res = INT_MAX;\n    for (int i = 1; i < n; ++i) res = min(res, dp[(1 << n) - 1][i] + dist[i][0]);\n    return res;\n}\n\nint main() {\n    vector<vector<int>> dist = {\n        {0, 10, 15, 20},\n        {10, 0, 35, 25},\n        {15, 35, 0, 30},\n        {20, 25, 30, 0}\n    };\n    cout << \"Minimum tour cost: \" << tsp(dist) << endl;\n    return 0;\n}",
    "mainImage": "",
    "slideshowImage": [],
    "category": [
      "Graph & Tree"
    ]
  },
  {
    "number": 59,
    "times_viewed": 0,
    "id": "lowest_common_ancestor",
    "name": "Lowest Common Ancestor",
    "description": "The Lowest Common Ancestor (LCA) of two nodes in a binary tree is the lowest node that has both nodes as descendants (including the node itself).\n\nExplaination:\nTo find the LCA, we recursively search the tree for the two target nodes. If we find either node, we return it. If both left and right recursive calls return non-null, the current node is the LCA. If only one side returns a node, we propagate that upward. This approach assumes both nodes are guaranteed to exist in the tree and works for both binary and binary search trees (with slight optimizations in BST). It is frequently used in tree-based problems, networks, and version-control ancestry.\n\nTime Complexity:\n- O(n) in the worst case\n\nSpace Complexity: O(h) where h is the height of the tree",
    "java": "class TreeNode {\n    int val;\n    TreeNode left, right;\n    TreeNode(int x) { val = x; }\n}\n\npublic class LowestCommonAncestor {\n    public static TreeNode lca(TreeNode root, TreeNode p, TreeNode q) {\n        if (root == null || root == p || root == q) return root;\n        TreeNode left = lca(root.left, p, q);\n        TreeNode right = lca(root.right, p, q);\n        if (left != null && right != null) return root;\n        return left != null ? left : right;\n    }\n\n    public static void main(String[] args) {\n        TreeNode root = new TreeNode(3);\n        root.left = new TreeNode(5);\n        root.right = new TreeNode(1);\n        root.left.left = new TreeNode(6);\n        root.left.right = new TreeNode(2);\n        root.right.left = new TreeNode(0);\n        root.right.right = new TreeNode(8);\n        TreeNode result = lca(root, root.left, root.left.right);\n        System.out.println(\"LCA: \" + result.val);\n    }\n}",
    "python": "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef lca(root, p, q):\n    if not root or root == p or root == q:\n        return root\n    left = lca(root.left, p, q)\n    right = lca(root.right, p, q)\n    if left and right:\n        return root\n    return left or right\n\nroot = TreeNode(3)\nroot.left = TreeNode(5)\nroot.right = TreeNode(1)\nroot.left.left = TreeNode(6)\nroot.left.right = TreeNode(2)\nroot.right.left = TreeNode(0)\nroot.right.right = TreeNode(8)\nresult = lca(root, root.left, root.left.right)\nprint(f''LCA: {result.val}'')",
    "cpp": "#include <iostream>\nusing namespace std;\n\nstruct TreeNode {\n    int val;\n    TreeNode* left;\n    TreeNode* right;\n    TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n};\n\nTreeNode* lca(TreeNode* root, TreeNode* p, TreeNode* q) {\n    if (!root || root == p || root == q) return root;\n    TreeNode* left = lca(root->left, p, q);\n    TreeNode* right = lca(root->right, p, q);\n    if (left && right) return root;\n    return left ? left : right;\n}\n\nint main() {\n    TreeNode* root = new TreeNode(3);\n    root->left = new TreeNode(5);\n    root->right = new TreeNode(1);\n    root->left->left = new TreeNode(6);\n    root->left->right = new TreeNode(2);\n    root->right->left = new TreeNode(0);\n    root->right->right = new TreeNode(8);\n    TreeNode* result = lca(root, root->left, root->left->right);\n    cout << \"LCA: \" << result->val << endl;\n    return 0;\n}",
    "mainImage": "",
    "slideshowImage": [],
    "category": [
      "Graph & Tree"
    ]
  },
  {
    "number": 60,
    "times_viewed": 0,
    "id": "m-coloring_roblem",
    "name": "M-Coloring Problem",
    "description": "The M-Coloring problem checks if it's possible to color a graph's vertices using at most M colors such that no two adjacent vertices share the same color.\n\nExplaination:\nThe problem is solved using backtracking. For each vertex, we try assigning a color from 1 to M. Before assigning, we check if the color is safe — i.e., none of the adjacent vertices have the same color. If we reach the end of the graph with valid colors, the graph is M-colorable. This is a classic constraint satisfaction problem used in scheduling and resource allocation.\n\nTime Complexity:\n- O(Mⁿ), where n is the number of vertices\n\nSpace Complexity: O(n) for the color array",
    "java": "public class MColoring {\n    public static boolean graphColoring(boolean[][] graph, int m) {\n        int[] color = new int[graph.length];\n        return solve(0, graph, color, m);\n    }\n\n    private static boolean solve(int node, boolean[][] graph, int[] color, int m) {\n        if (node == graph.length) return true;\n        for (int c = 1; c <= m; c++) {\n            if (isSafe(node, graph, color, c)) {\n                color[node] = c;\n                if (solve(node + 1, graph, color, m)) return true;\n                color[node] = 0;\n            }\n        }\n        return false;\n    }\n\n    private static boolean isSafe(int node, boolean[][] graph, int[] color, int c) {\n        for (int i = 0; i < graph.length; i++) {\n            if (graph[node][i] && color[i] == c) return false;\n        }\n        return true;\n    }\n\n    public static void main(String[] args) {\n        boolean[][] graph = {\n            {false, true, true, true},\n            {true, false, true, false},\n            {true, true, false, true},\n            {true, false, true, false}\n        };\n        int m = 3;\n        System.out.println(\"M-Colorable: \" + graphColoring(graph, m));\n    }\n}",
    "python": "def is_safe(node, graph, color, c):\n    for i in range(len(graph)):\n        if graph[node][i] and color[i] == c:\n            return False\n    return True\n\ndef solve(node, graph, m, color):\n    if node == len(graph):\n        return True\n    for c in range(1, m+1):\n        if is_safe(node, graph, color, c):\n            color[node] = c\n            if solve(node+1, graph, m, color):\n                return True\n            color[node] = 0\n    return False\n\ndef graph_coloring(graph, m):\n    color = [0] * len(graph)\n    return solve(0, graph, m, color)\n\ngraph = [\n    [0,1,1,1],\n    [1,0,1,0],\n    [1,1,0,1],\n    [1,0,1,0]\n]\nm = 3\nprint(f''M-Colorable: {graph_coloring(graph, m)}'')",
    "cpp": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nbool isSafe(int node, vector<vector<bool>>& graph, vector<int>& color, int c) {\n    for (int i = 0; i < graph.size(); i++) {\n        if (graph[node][i] && color[i] == c) return false;\n    }\n    return true;\n}\n\nbool solve(int node, vector<vector<bool>>& graph, vector<int>& color, int m) {\n    if (node == graph.size()) return true;\n    for (int c = 1; c <= m; c++) {\n        if (isSafe(node, graph, color, c)) {\n            color[node] = c;\n            if (solve(node + 1, graph, color, m)) return true;\n            color[node] = 0;\n        }\n    }\n    return false;\n}\n\nbool graphColoring(vector<vector<bool>>& graph, int m) {\n    vector<int> color(graph.size(), 0);\n    return solve(0, graph, color, m);\n}\n\nint main() {\n    vector<vector<bool>> graph = {\n        {0,1,1,1},\n        {1,0,1,0},\n        {1,1,0,1},\n        {1,0,1,0}\n    };\n    int m = 3;\n    cout << \"M-Colorable: \" << (graphColoring(graph, m) ? \"true\" : \"false\") << endl;\n    return 0;\n}",
    "mainImage": "",
    "slideshowImage": [],
    "category": [
      "Recursion & Backtracking"
    ]
  },
  {
    "number": 61,
    "times_viewed": 0,
    "id": "hamiltonian_path",
    "name": "Hamiltonian Path",
    "description": "The Hamiltonian Path problem finds a path in a graph that visits every vertex exactly once, optionally returning to the starting point (Hamiltonian Circuit).\n\nExplaination:\nThe algorithm tries all permutations of vertex visits using backtracking. Starting from each vertex, we attempt to visit all other unvisited vertices exactly once. If we reach the end with all visited, a Hamiltonian path is found. It's used in route planning, scheduling, and is NP-complete in general graphs.\n\nTime Complexity:\n- O(n!) in the worst case\n\nSpace Complexity: O(n) for path and visited array",
    "java": "public class HamiltonianPath {\n    static boolean backtrack(int[][] graph, boolean[] visited, int pos, int count) {\n        if (count == graph.length) return true;\n        visited[pos] = true;\n        for (int i = 0; i < graph.length; i++) {\n            if (graph[pos][i] == 1 && !visited[i]) {\n                if (backtrack(graph, visited, i, count + 1)) return true;\n            }\n        }\n        visited[pos] = false;\n        return false;\n    }\n    public static boolean hasHamiltonianPath(int[][] graph) {\n        for (int i = 0; i < graph.length; i++) {\n            boolean[] visited = new boolean[graph.length];\n            if (backtrack(graph, visited, i, 1)) return true;\n        }\n        return false;\n    }\n    public static void main(String[] args) {\n        int[][] graph = {\n            {0, 1, 1, 0},\n            {1, 0, 1, 1},\n            {1, 1, 0, 1},\n            {0, 1, 1, 0}\n        };\n        System.out.println(\"Hamiltonian Path exists: \" + hasHamiltonianPath(graph));\n    }\n}",
    "python": "def backtrack(graph, visited, pos, count):\n    if count == len(graph): return True\n    visited[pos] = True\n    for i in range(len(graph)):\n        if graph[pos][i] == 1 and not visited[i]:\n            if backtrack(graph, visited, i, count+1): return True\n    visited[pos] = False\n    return False\n\ndef has_hamiltonian_path(graph):\n    for i in range(len(graph)):\n        visited = [False] * len(graph)\n        if backtrack(graph, visited, i, 1): return True\n    return False\n\ngraph = [\n    [0,1,1,0],\n    [1,0,1,1],\n    [1,1,0,1],\n    [0,1,1,0]\n]\nprint(f''Hamiltonian Path exists: {has_hamiltonian_path(graph)}'')",
    "cpp": "#include <iostream>\n#include <vector>\nusing namespace std;\nbool backtrack(vector<vector<int>>& graph, vector<bool>& visited, int pos, int count) {\n    if (count == graph.size()) return true;\n    visited[pos] = true;\n    for (int i = 0; i < graph.size(); i++) {\n        if (graph[pos][i] == 1 && !visited[i]) {\n            if (backtrack(graph, visited, i, count + 1)) return true;\n        }\n    }\n    visited[pos] = false;\n    return false;\n}\nbool hasHamiltonianPath(vector<vector<int>>& graph) {\n    for (int i = 0; i < graph.size(); i++) {\n        vector<bool> visited(graph.size(), false);\n        if (backtrack(graph, visited, i, 1)) return true;\n    }\n    return false;\n}\nint main() {\n    vector<vector<int>> graph = {\n        {0,1,1,0},\n        {1,0,1,1},\n        {1,1,0,1},\n        {0,1,1,0}\n    };\n    cout << \"Hamiltonian Path exists: \" << (hasHamiltonianPath(graph) ? \"true\" : \"false\") << endl;\n    return 0;\n}",
    "mainImage": "",
    "slideshowImage": [],
    "category": [
      "Recursion & Backtracking"
    ]
  },
  {
    "number": 62,
    "times_viewed": 0,
    "id": "kmp_algorithm",
    "name": "KMP Algorithm",
    "description": "The KMP algorithm searches for occurrences of a pattern within a string using a preprocessed LPS (Longest Prefix Suffix) array for efficient shifting.\n\nExplaination:\nInstead of rechecking matched characters after a mismatch like in naive search, KMP preprocesses the pattern to build an LPS array. This allows skipping characters while matching. KMP ensures linear time search in all cases and is widely used in text processing, DNA sequence matching, and IDE search tools.\n\nTime Complexity:\n- O(n + m) where n = text length, m = pattern length\n\nSpace Complexity: O(m) for LPS array",
    "java": "public class KMP {\n    public static void computeLPS(String pat, int[] lps) {\n        int len = 0, i = 1;\n        while (i < pat.length()) {\n            if (pat.charAt(i) == pat.charAt(len)) lps[i++] = ++len;\n            else if (len != 0) len = lps[len - 1];\n            else lps[i++] = 0;\n        }\n    }\n    public static void KMPSearch(String txt, String pat) {\n        int[] lps = new int[pat.length()];\n        computeLPS(pat, lps);\n        int i = 0, j = 0;\n        while (i < txt.length()) {\n            if (txt.charAt(i) == pat.charAt(j)) { i++; j++; }\n            if (j == pat.length()) {\n                System.out.println(\"Pattern found at index \" + (i - j));\n                j = lps[j - 1];\n            } else if (i < txt.length() && txt.charAt(i) != pat.charAt(j)) {\n                if (j != 0) j = lps[j - 1]; else i++;\n            }\n        }\n    }\n    public static void main(String[] args) {\n        KMPSearch(\"abxabcabcaby\", \"abcaby\");\n    }\n}",
    "python": "def compute_lps(pattern):\n    lps = [0] * len(pattern)\n    length = 0\n    i = 1\n    while i < len(pattern):\n        if pattern[i] == pattern[length]:\n            length += 1\n            lps[i] = length\n            i += 1\n        else:\n            if length != 0:\n                length = lps[length-1]\n            else:\n                lps[i] = 0\n                i += 1\n    return lps\n\ndef kmp_search(text, pattern):\n    lps = compute_lps(pattern)\n    i = j = 0\n    while i < len(text):\n        if text[i] == pattern[j]:\n            i += 1\n            j += 1\n            if j == len(pattern):\n                print(f''Pattern found at index {i - j}'')\n                j = lps[j-1]\n        else:\n            if j != 0:\n                j = lps[j-1]\n            else:\n                i += 1\n\nkmp_search('abxabcabcaby', 'abcaby')",
    "cpp": "#include <iostream>\n#include <vector>\nusing namespace std;\nvoid computeLPS(string& pat, vector<int>& lps) {\n    int len = 0, i = 1;\n    while (i < pat.size()) {\n        if (pat[i] == pat[len]) lps[i++] = ++len;\n        else if (len != 0) len = lps[len - 1];\n        else lps[i++] = 0;\n    }\n}\nvoid KMPSearch(string txt, string pat) {\n    vector<int> lps(pat.size(), 0);\n    computeLPS(pat, lps);\n    int i = 0, j = 0;\n    while (i < txt.size()) {\n        if (txt[i] == pat[j]) { i++; j++; }\n        if (j == pat.size()) {\n            cout << \"Pattern found at index \" << (i - j) << endl;\n            j = lps[j - 1];\n        } else if (i < txt.size() && txt[i] != pat[j]) {\n            if (j != 0) j = lps[j - 1]; else i++;\n        }\n    }\n}\nint main() {\n    KMPSearch(\"abxabcabcaby\", \"abcaby\");\n    return 0;\n}",
    "mainImage": "https://res.cloudinary.com/df1muxilg/image/upload/v1751438196/52814ade-710e-4d7c-9f5f-32dbe1c030f7.png",
    "slideshowImage": ["https://res.cloudinary.com/df1muxilg/image/upload/v1751438157/3769c32a-5238-474b-98f0-0e6016b256c2.png", "https://res.cloudinary.com/df1muxilg/image/upload/v1751438267/3d6c4f8c-3210-43ab-8773-93c6f5479de2.png", "https://res.cloudinary.com/df1muxilg/image/upload/v1751438302/90701942-b5f3-4f15-839d-74a3da420669.png", "https://res.cloudinary.com/df1muxilg/image/upload/v1751438339/dcfe8ef3-322c-4abe-a8e0-4439a64b15f7.png", "https://res.cloudinary.com/df1muxilg/image/upload/v1751438387/b89e4bfc-f8ec-4736-a3dc-fb2b266e74e4.png", "https://res.cloudinary.com/df1muxilg/image/upload/v1751438413/a8c588f7-09d7-4126-9051-d6d5be76838b.png", "https://res.cloudinary.com/df1muxilg/image/upload/v1751438472/f6e966b8-888b-49b6-b441-69f5ab0e5925.png", "https://res.cloudinary.com/df1muxilg/image/upload/v1751438508/c798a6ce-2cce-40d8-8fe6-01c0a75ab799.png", "https://res.cloudinary.com/df1muxilg/image/upload/v1751438547/3cb1c3cb-2171-45b9-9c68-3fd5033b396a.png" ],
    "category": [
      "Graph & Tree"
    ]
  }
]